<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DQQ&#39;s blog</title>
  
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/"/>
  <updated>2023-03-08T02:51:24.079Z</updated>
  <id>https://xiaoxiaoguaixiashi.github.io.git/</id>
  
  <author>
    <name>DQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2022-23648分析复现</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2023/03/07/CVE-2022-23648/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2023/03/07/CVE-2022-23648/</id>
    <published>2023-03-07T01:36:44.000Z</published>
    <updated>2023-03-08T02:51:24.079Z</updated>
    
    <content type="html"><![CDATA[<p>本篇参考st0n3首发的《containerd CVE-2022-23648 分析与复现》一文，介绍了容器运行时软件containerd漏洞的相关情况，并分析了CVE-2022-23648利用时容器在系统层面的活动信息。</p><span id="more"></span><h1 id="一-漏洞信息"><a href="#一-漏洞信息" class="headerlink" title="一 漏洞信息"></a>一 漏洞信息</h1><ul><li>组件介绍：containerd作为High-level运行时软件，包含了更多上层功能，包括镜像存储管理，容器运行管理等，并传递给runc等Low-level运行时软件。</li><li>漏洞介绍：CVE-2022-23648是一处针对宿主机任意文件的越权读取漏洞，该漏洞使攻击者可以通过部署特殊配置的恶意镜像，绕过Pod Security Policy等安全机制的约束获取宿主机上的敏感信息。</li><li>影响范围：containerd版本为≤v1.4.12、v1.5.0~v1.5.9、v1.6.0。</li><li>危害：可以读取宿主机任意文件，而宿主机上可能包括允许容器逃逸的敏感信息。</li></ul><h1 id="二-检测方案"><a href="#二-检测方案" class="headerlink" title="二 检测方案"></a>二 检测方案</h1><ul><li>因为复制宿主机文件的操作由containerd执行，因此只能从行为层面检测。可以通过检测containerd复制宿主机操作系统关键文件的行为，判定该漏洞是否被利用。</li></ul><h1 id="三-漏洞复现"><a href="#三-漏洞复现" class="headerlink" title="三 漏洞复现"></a>三 漏洞复现</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/containerd/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/CVE-2022-23648/%E5%88%86%E6%9E%90/containerd-CVE-2022-23648-%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html">st0n3博客——containerd CVE-2022-23648 分析与复现</a></li><li><a href="https://github.com/raesene/CVE-2022-23648-POC">CVE-2022-23648-POC</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇参考st0n3首发的《containerd CVE-2022-23648 分析与复现》一文，介绍了容器运行时软件containerd漏洞的相关情况，并分析了CVE-2022-23648利用时容器在系统层面的活动信息。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="CVE" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核函数分析</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2023/02/28/Linux-function-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2023/02/28/Linux-function-md/</id>
    <published>2023-02-28T14:28:22.000Z</published>
    <updated>2023-03-06T13:55:59.397Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了Linux内核源码的结构组成，并进一步分析了容器源码，介绍了Linux中与容器相关的capabilities机制。</p><span id="more"></span><h1 id="一-Linux内核源码整体组成"><a href="#一-Linux内核源码整体组成" class="headerlink" title="一 Linux内核源码整体组成"></a>一 Linux内核源码整体组成</h1><ul><li>现代操作系统一般由进程管理、内存管理、文件系统、驱动程序、网络等组成，Linux内核源码下的各个目录大致对应了这些部分。</li><li>ll &#x2F;usr&#x2F;src&#x2F;linux<blockquote><ul><li>arch：包含了支持的硬件体系结构相关的核心代码。</li><li>block：存储了块设备驱动的相关代码。</li><li>certs：存储了认证和签名的相关代码。</li><li>crypto：存储了内核中常用的加密、压缩等算法的相关代码。</li><li>documentation：内核中常用的协议规范、功能模块等。</li><li>drivers：包含系统中所有的设备驱动，如显卡驱动程序等。</li><li>fs：fs目录中存储了虚拟文件系统相关代码，每个逻辑文件系统在fs下都有对应的目录，如ext2等。</li><li>include：包括了核心的大多数include文件，对于每种支持的体系结构分别有一个子目录。</li><li>init：包含核心启动代码，该初始化代码关联到了内核的各个组件的入口。</li><li>ipc：包含了核心的进程间通讯代码，如信号量、共享内存等。</li><li>io_uring：新的异步IO框架。</li><li>kernel：主要核心代码，包含了进程管理、IRQ中断等模块。</li><li>lib：包含了核心的库代码，存储了C语言标准库的子集相关代码。</li><li>mm：包含了所有的内存管理代码，与具体硬件体系结构相关的内存管理代码位于arch&#x2F;*&#x2F;mm目录。</li><li>net：核心的网络部分代码，每个子目录对应于网络的一个方面。</li><li>samples： 存储了Linux内核参考示例代码。</li><li>scripts：包含用于配置核心的脚本文件。</li><li>security：存储了Linux内核安全模型相关代码。</li><li>sound：存储了声卡驱动相关代码。</li><li>tools：存储了与Linux内核交互相关代码。</li><li>usr：存储了用户打包和内核压缩相关代码。</li><li>virt：存储了kvm虚拟化目录相关实现的代码。</li></ul></blockquote></li></ul><h1 id="二-Linux中与容器相关的函数调用"><a href="#二-Linux中与容器相关的函数调用" class="headerlink" title="二 Linux中与容器相关的函数调用"></a>二 Linux中与容器相关的函数调用</h1><h2 id="2-1-docker容器源码分析"><a href="#2-1-docker容器源码分析" class="headerlink" title="2.1 docker容器源码分析"></a>2.1 docker容器源码分析</h2><p>容器引擎–&gt;containerd High-level 运行时–&gt;runc Low-level 容器运行时。</p><ul><li>1、首先分析容器引擎moby源码：从moby&#x2F;daemon&#x2F;create.go源码中可知，daemon端先进行container create（调用ContainerCreate进一步创建容器——&gt;daemon.create(params, managed)——&gt;daemon.newContainer()），然后对container start进行处理（r.postContainersCreate()——&gt;ContainerStart()——&gt;daemon.containerStart()——&gt;daemon.containerd.Create()——&gt;container.start()），接下里的内容就交给了docker-containerd继续处理。</li><li>2、然后分析容器运行时containerd代码：Container.NewTask——&gt;TaskService()——&gt;Runtime TaskManager Create——&gt;runc.create()。</li><li>3、runc create –&gt; runc init –&gt; runc start，三者关系时序图如下。其中，runc create为runc init做准备工作，runc init很少被直接使用，而是被runc create隐式地调用。<br><img src="/assets/blog/Linux-function-1.jpg" alt="Alt text"><br><center>图来自(参考链接“runc源码分析”)</center></li></ul><p>runc&#x2F;create.go——&gt;runc&#x2F;utils_linux.go中的startContainer——&gt;createContainer——&gt;CreateLibcontainerConfig——&gt;CreateCgroupConfig（创建cgroup资源控制的配置, 传入默认分区, 返回cgroup资源配置）——&gt;runc&#x2F;libcontainer&#x2F;process_linux.go initProcess.start中通知init 进程，设置新的cgroup namespace，执行nsexec进程。</p><ul><li>4、runc经过多次自身调用，历经新旧namespace创建和切换，最后执行entrypoint替换掉runc自身进程。<br><img src="/assets/blog/Linux-function-2.jpg" alt="Alt text"><br><center>跟namespace相关的三个函数：clone()、setns（）、unshare()</center></li></ul><h2 id="2-2-sysdig实现docker跟踪"><a href="#2-2-sysdig实现docker跟踪" class="headerlink" title="2.2 sysdig实现docker跟踪"></a>2.2 sysdig实现docker跟踪</h2><p><img src="/assets/blog/Linux-function-3.jpg" alt="Alt text"><br></p><center>sysdig架构</center><h2 id="2-3-capabilities检查容器权限"><a href="#2-3-capabilities检查容器权限" class="headerlink" title="2.3 capabilities检查容器权限"></a>2.3 capabilities检查容器权限</h2><h3 id="2-3-1-capabilities相关概念"><a href="#2-3-1-capabilities相关概念" class="headerlink" title="2.3.1 capabilities相关概念"></a>2.3.1 capabilities相关概念</h3><p>capabilities可以应用于文件和进程（或线程，Linux 内核不区分进程和线程），文件的capabilities存储在文件的扩展属性中，扩展属性在构建镜像时会被清理掉，所以在容器中基本不需要考虑文件的capabilities。<br>进程的capabilities通过每个进程单独维护的5个capability集合来控制，每个集合中都包含0个或多个capabilities：</p><ul><li>Permitted：进程所能够使用的capabilities的超集；</li><li>Inheritable：进程在执行exec() 统调用时，能够被新的派生进程所继承的capabilities；</li><li>Effective：内核对进程执行权限检查时所使用的集合；</li><li>Bounding：Inheritable 集合的超集，一个capability 必须在 Bounding 集合中才能添加到Inheritable；</li><li>Ambient：非特权程序执行exec()系统调用时将保留的 capabilities。<br>如内核代码<a href="https://elixir.bootlin.com/linux/v5.18/source/include/linux/cred.h#L110%E4%B8%AD%E6%89%80%E7%A4%BA%EF%BC%9A">https://elixir.bootlin.com/linux/v5.18/source/include/linux/cred.h#L110中所示：</a><br><img src="/assets/blog/Linux-function-4.jpg" alt="Alt text"><br><center>进程结构体中的capability集合</center></li></ul><h3 id="2-3-2-权限检查"><a href="#2-3-2-权限检查" class="headerlink" title="2.3.2 权限检查"></a>2.3.2 权限检查</h3><ul><li>引入capabilities后，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是root，就去检查是否具有该特权操作所对应的capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有capability CAP_KILL；如果设置系统时间，就得具有capability CAP_SYS_TIME。</li><li>capabilities列表见<a href="https://man7.org/linux/man-pages/man7/capabilities.7.html%E3%80%82">https://man7.org/linux/man-pages/man7/capabilities.7.html。</a></li></ul><h3 id="2-3-3-获取和设置capabilities"><a href="#2-3-3-获取和设置capabilities" class="headerlink" title="2.3.3 获取和设置capabilities"></a>2.3.3 获取和设置capabilities</h3><ul><li>系统调用capget(2)和capset(2)，可被用于获取和设置线程自身的capabilities。</li><li>此外，也可以使用libcap中提供的接口cap_get_proc(3)和cap_set_proc(3)。</li><li>如果要查看线程的capabilities，可以通过&#x2F;proc&#x2F;<PID>&#x2F;task&#x2F;<TID>&#x2F;status文件，三种集合分别对应于CapPrm, CapInh和CapEff。但这种的显示结果是数值，不适合阅读。为此，可使用包libcap中的命令getpcaps <PID>获取该进程的主线程的capabilities。</li><li>类似的，如果要查看和设置文件的capabilities，可以使用命令getcap或者setcap。</li><li>Linux源码中对capabilities权限检查的实现在kernel&#x2F;capability.c中。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/375238002">博客文章——Linux内核源代码查看及分析方法</a></li><li><a href="https://guanjunjian.github.io/2017/09/28/study-4-docker-4-postContainersCreate/">博客文章——Docker源码分析</a></li><li><a href="https://juejin.cn/post/6903527508784873485">博客文章——runc源码分析</a></li><li><a href="https://toutiao.io/posts/9t5ta44/preview">博客文章——runc源码分析2</a></li><li><a href="https://www.bilibili.com/read/cv19784745?from=search">博客文章——深究Runc源码-3-Init流程分析</a></li><li><a href="https://waynerv.com/posts/container-fundamentals-permission-control-using-capabilities/">博客文章——容器技术原理(四)：使用 Capabilities 实现权限控制</a></li><li><a href="https://www.ctfiot.com/91844.html">博客文章——Linux Capabilities利用总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了Linux内核源码的结构组成，并进一步分析了容器源码，介绍了Linux中与容器相关的capabilities机制。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="Linux" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF编程实战</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2023/01/18/eBPF-3-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2023/01/18/eBPF-3-md/</id>
    <published>2023-01-18T07:45:40.000Z</published>
    <updated>2023-03-08T02:50:21.548Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中介绍了eBPF编程入门的基础内容和结构，本篇进一步分析了BPF技术中的重要数据结构。此外，过去许多BPF应用程序都是基于BCC实现的，但libbpf+BPF CO-RE的方式无疑更好上手。因此，本篇中也说明了由BCC转换到libbpf过程中需要注意的一些问题。</p><span id="more"></span><h2 id="一、BPF-Map"><a href="#一、BPF-Map" class="headerlink" title="一、BPF Map"></a>一、BPF Map</h2><ul><li>BPF Map以“键&#x2F;值”方式存储在内核中，可以被任何BPF程序访问。在内核空间的程序创建BPF Map并返回对应的文件描述符，在用户空间运行的程序就可以通过文件描述符来访问并操作BPF Map。</li><li>BPF映射提供了内核和用户空间双向数据共享，允许用户从内核和用户空间读取和写入数据。BPF映射的数据结构类型可以从简单数组、哈希映射到自定义类型映射。</li></ul><h2 id="二、BCC到libbpf的转换"><a href="#二、BCC到libbpf的转换" class="headerlink" title="二、BCC到libbpf的转换"></a>二、BCC到libbpf的转换</h2><h3 id="2-1-构建基于libbpf的应用程序"><a href="#2-1-构建基于libbpf的应用程序" class="headerlink" title="2.1 构建基于libbpf的应用程序"></a>2.1 构建基于libbpf的应用程序</h3><p>参考PRovBPF，笔者总结了一个通用的Makefile规则，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">btf:</span></span><br><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; <span class="keyword">include</span>/kern/vmlinux.h</span><br><span class="line"></span><br><span class="line"><span class="section">kern:</span></span><br><span class="line">clang -O2 -Wall \</span><br><span class="line">-Iinclude \</span><br><span class="line">-target bpf -g -c kern.c -o project.o</span><br><span class="line"></span><br><span class="line"><span class="section">skel:</span></span><br><span class="line">bpftool gen skeleton project.o &gt; <span class="keyword">include</span>/usr/project.skel.h</span><br><span class="line"></span><br><span class="line"><span class="section">usr:</span></span><br><span class="line">clang -Wall usr.c -o usr.o -Iinclude -c</span><br><span class="line">clang -Wall service.c -o service.o -Iinclude -c</span><br><span class="line">clang -o projectd \</span><br><span class="line">service.o \</span><br><span class="line">usr.o \</span><br><span class="line">-lbpf -lpthread -linih</span><br><span class="line"></span><br><span class="line"><span class="section">usr_dbg:</span></span><br><span class="line">clang -g usr.c -o usr.o -Iinclude -c</span><br><span class="line">clang -g service.c -o service.o -Iinclude -c</span><br><span class="line">clang -g -o projectd \</span><br><span class="line">service.o \</span><br><span class="line">usr.o \</span><br><span class="line">-lbpf -lpthread -linih</span><br><span class="line"></span><br><span class="line"><span class="section">all: clean btf kern skel usr</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o</span><br><span class="line">rm -f <span class="keyword">include</span>/usr/project.skel.h</span><br><span class="line">rm -f <span class="keyword">include</span>/kern/vmlinux.h</span><br><span class="line">rm -rf output</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">sudo cp --force ./projectd /usr/bin/projectd</span><br><span class="line">sudo cp --force ./projectd.service /etc/systemd/system/projectd.service</span><br><span class="line">sudo systemctl enable projectd.service</span><br><span class="line"></span><br><span class="line"><span class="section">start:</span></span><br><span class="line">sudo systemctl start projectd.service</span><br><span class="line"></span><br><span class="line"><span class="section">stop:</span></span><br><span class="line">sudo systemctl stop projectd.service</span><br><span class="line"></span><br><span class="line"><span class="section">status:</span></span><br><span class="line">sudo systemctl status projectd.service</span><br><span class="line"></span><br><span class="line"><span class="section">uninstall:</span></span><br><span class="line">sudo systemctl stop projectd.service</span><br><span class="line">sudo systemctl disable projectd.service</span><br><span class="line">sudo rm -f /usr/bin/projectd</span><br><span class="line">sudo rm -f /etc/systemd/system/projectd.service</span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">rm -rf audit.log</span><br><span class="line">sudo projectd</span><br></pre></td></tr></table></figure><h3 id="2-2-使用libbpf和BCC的区别"><a href="#2-2-使用libbpf和BCC的区别" class="headerlink" title="2.2 使用libbpf和BCC的区别"></a>2.2 使用libbpf和BCC的区别</h3><ul><li>使用libbpf&#x2F;BPF CO-RE，不需要包含内核头文件（即，所有这些 #include &lt;linux&#x2F;whatever.h&gt;）， 而是包含一个 vmlinux.h和几个libbpf帮助头文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span>               <span class="comment">/* all kernel types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span>       <span class="comment">/* most used helpers: SEC, __always_inline, etc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span>     <span class="comment">/* for BPF CO-RE helpers */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span>       <span class="comment">/* for getting kprobe arguments */</span></span></span><br></pre></td></tr></table></figure></li><li>BCC和libbpf以声明方式定义map的方式有所不同，libbpf以struct结构体的形式定义map数据，并需要明确指定大小。</li><li>常见libbpf命名规范：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tp/&lt;category&gt;/&lt;name&gt; 用于 tracepoints；</span><br><span class="line">kprobe/&lt;func_name&gt; 用于 kprobe 和 kretprobe/&lt;func_name&gt; 用于 kretprobe；</span><br><span class="line">raw_tp/&lt;name&gt; 用于原始 tracepoint；</span><br><span class="line">cgroup_skb/ingress 、cgroup_skb/egress 和整个系列的 cgroup/&lt;subtype&gt; 程序。</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、BPF-ring-buffer-和-BPF-perf-buffer"><a href="#三、BPF-ring-buffer-和-BPF-perf-buffer" class="headerlink" title="三、BPF ring buffer 和 BPF perf buffer"></a>三、BPF ring buffer 和 BPF perf buffer</h2><ul><li>Perf Buffer是每个CPU缓冲区的集合，允许内核和用户空间之间高效地交换数据，但由于perfbuf是基于CPU的设计，存在内存使用效率低和事件重新排序的缺点。</li><li>从Linux 5.8开始，BPF提供了ring buffer，是一个多生产者单消费者队列，可以同时在多个CPU之间安全地共享，解决了perfbuf内存开销和数据排序的问题。<br><br>以下分析针对<a href="https://www.ebpf.top/post/bpf_ring_buffer/">博客文章——BPF 环形缓冲区</a>中开源的例子：<br></li></ul><h3 id="3-1-perf-buffer"><a href="#3-1-perf-buffer" class="headerlink" title="3.1 perf buffer"></a>3.1 perf buffer</h3><ul><li>1、定义事件的数据结构，此数据结构用于BPF程序发送的数据，同时用于程序的用户空间部分使用。</li><li>2、定义BPF perfbuf为BPF_MAP_TYPE_PERF_EVENT_ARRAY映射。</li><li>3、BPF程序：附加到跟踪点上，为样本获取一个临时存储，并用跟踪点上下文中的数据填充它。完成后，它将通过调用bpf_perf_event_output()发送样本到BPF perfbuf。该API会在当前CPU的perf缓冲区中为数据结构event预留空间，将数据复制到该预留空间，完成后将向用户空间发出新数据可用的信号。此时，epoll子系统将唤醒用户空间处理程序，并将指针传递到该数据副本进行处理。</li><li>4、用户空间部分：使用libbpf用户空间的perf_buffer__new() API创建一个perf缓冲区使用实例，对于提交样本libbpf将调用handle_event()回调，该回调仅调用printf()打印数据。</li></ul><h3 id="3-2-ring-buffer"><a href="#3-2-ring-buffer" class="headerlink" title="3.2 ring buffer"></a>3.2 ring buffer</h3><ul><li>1、BPF程序的区别：bpf_perf_event_output()类似于bpf_ringbuf_output()，是bpf_ringbuf_output()的替代，唯一的区别是ringbuf API不需要引用BPF程序上下文。此外，BPF ringbuf 映射定义略有不同。</li><li>2、用户空间代码：更简单的ring_buffer__new() API，ring_buffer__poll() 替换 perf_buffer__poll().</li><li>3、首选reserve&#x2F;commit API，相比bpf_ringbuf_output()，消除了额外的内存复制和临时存储空间的需求。</li></ul><h2 id="四、开发过程中遇到的一些问题"><a href="#四、开发过程中遇到的一些问题" class="headerlink" title="四、开发过程中遇到的一些问题"></a>四、开发过程中遇到的一些问题</h2><h3 id="4-1-vmlinux头文件中类型重定义错误"><a href="#4-1-vmlinux头文件中类型重定义错误" class="headerlink" title="4.1 vmlinux头文件中类型重定义错误"></a>4.1 vmlinux头文件中类型重定义错误</h3><ul><li>解决方案：vmlinux.h和bpf.h冲突，删除bpf.h include。</li></ul><h3 id="4-2-如何在BPF程序中按照PID过滤"><a href="#4-2-如何在BPF程序中按照PID过滤" class="headerlink" title="4.2 如何在BPF程序中按照PID过滤"></a>4.2 如何在BPF程序中按照PID过滤</h3><ul><li>问题分析：PID是进程标识符，按照PID过滤则需要了解进程在内核空间的结构。</li><li>Linux进程：<br>在Linux系统中进程在内核空间一般用任务&#x2F;Task来表示，内核中对应的结构为task_struct。<br>用户创建的线程在Linux内核中也会对等创建一个task_struct结构，属于同一个进程的多个线程对应的task_struct结构在底层实现了进程级别资源的共享，比如内存、信号量、文件等。<br></li><li>进程pid的过滤：bpf_get_current_pid_tgid() &gt;&gt; 32，高32位置为tgid，低32位为 pid(tid)。</li></ul><h3 id="4-3-如何获得挂载点上下文信息的格式"><a href="#4-3-如何获得挂载点上下文信息的格式" class="headerlink" title="4.3 如何获得挂载点上下文信息的格式"></a>4.3 如何获得挂载点上下文信息的格式</h3><ul><li>解决方案： cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;sched&#x2F;sched_process_fork&#x2F;format</li></ul><h2 id="五、如何查询内核中的跟踪点"><a href="#五、如何查询内核中的跟踪点" class="headerlink" title="五、如何查询内核中的跟踪点"></a>五、如何查询内核中的跟踪点</h2><p>事件源：Kprobe、Tracepoint、Uprobe以及USDT。</p><p><img src="/assets/blog/eBPF3-1.jpg" alt="Alt text"><br></p><center>图截取自报告《eBPF概念及在可观测性、网络、安全和优化领域的应用》</center><h3 id="5-1-利用调试信息查询跟踪点"><a href="#5-1-利用调试信息查询跟踪点" class="headerlink" title="5.1 利用调试信息查询跟踪点"></a>5.1 利用调试信息查询跟踪点</h3><ul><li>为了方便调试，内核把所有函数以及非栈变量的地址都抽取到了 <strong>&#x2F;proc&#x2F;kallsyms</strong>中，调试器可以根据地址找出对应的函数和变量名称。然而，不是所有的内核函数都是可跟踪的，只有显式导出的内核函数才可以被eBPF进行动态跟踪。因而，通常我们并不直接从内核符号表查询可跟踪点。</li><li>为了方便内核开发者获取所需的跟踪点信息，内核<strong>调试文件系统</strong>还向用户空间提供了内核调试所需的基本信息，如内核符号列表、跟踪点、函数跟踪（ftrace）状态以及参数格式等。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核调试文件系统的具体信息</span></span><br><span class="line">sudo ls /sys/kernel/debug</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询execve系统调用的参数格式</span></span><br><span class="line">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format</span><br></pre></td></tr></table></figure></li><li>有了调试文件系统，可以从&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing中找到所有内核预定义的跟踪点，进而可以在需要时把eBPF程序挂载到对应的跟踪点。</li></ul><h3 id="5-2-利用bpftrace查询跟踪点"><a href="#5-2-利用bpftrace查询跟踪点" class="headerlink" title="5.2 利用bpftrace查询跟踪点"></a>5.2 利用bpftrace查询跟踪点</h3><ul><li>bpftrace会把你开发的脚本借助BCC编译加载到内核中执行，再通过BPF映射获取执行的结果。因此，在编写简单的eBPF程序，特别是编写的eBPF程序用于临时的调试和排错时，可以考虑直接使用bpftrace，而不需要用C或Python去开发一个复杂的程序。</li><li>可以执行 <strong>bpftrace -l</strong> 来查询内核插桩和跟踪点：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有的系统调用跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;tracepoint:syscalls:*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有名字包含&quot;execve&quot;的跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure></li><li>对于跟踪点来说，还可以加上-v参数查询函数的入口参数或返回值。而由于内核函数属于不稳定的API，在bpftrace中只能通过 arg0、arg1 这样的参数来访问，具体的参数格式还需要参考内核源代码。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询execve入口参数格式</span></span><br><span class="line">sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">$ tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询execve返回值格式</span></span><br><span class="line">sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">$ tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-跟踪点的选取"><a href="#5-3-跟踪点的选取" class="headerlink" title="5.3 跟踪点的选取"></a>5.3 跟踪点的选取</h3><ul><li>内核插桩（kprobe）属于不稳定接口，而跟踪点（tracepoint）则是稳定接口。因而，在内核插桩和跟踪点两者都可用的情况下，应该选择<strong>更稳定的跟踪点</strong>，以保证eBPF程序的可移植性（即在不同版本的内核中都可以正常执行）。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://davidlovezoe.club/wordpress/archives/1044">博客文章——BPF数据传递的桥梁——BPF MAP</a></li><li><a href="https://www.ebpf.top/post/bcc-to-libbpf-guid/">BCC 到 libbpf 的转换指南【译】</a></li><li><a href="https://www.ebpf.top/post/ebpf_prog_pid_filter/">博客文章——如何在 BPF 程序中正确地按照 PID 过滤？</a></li><li><a href="https://www.ebpf.top/post/bpf_ring_buffer/">博客文章——BPF 环形缓冲区</a></li><li>中山大学陈鹏飞报告：eBPF概念及在可观测性、网络、安全和优化领域的应用</li><li><a href="https://time.geekbang.org/column/article/484207">极客时间——eBPF核心技术与实战</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章中介绍了eBPF编程入门的基础内容和结构，本篇进一步分析了BPF技术中的重要数据结构。此外，过去许多BPF应用程序都是基于BCC实现的，但libbpf+BPF CO-RE的方式无疑更好上手。因此，本篇中也说明了由BCC转换到libbpf过程中需要注意的一些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="eBPF" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF编程入门</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2022/10/19/eBPF-2-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2022/10/19/eBPF-2-md/</id>
    <published>2022-10-19T01:51:45.000Z</published>
    <updated>2023-02-27T12:32:08.817Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中介绍了eBPF初步学习的相关基础知识点，对eBPF开发环境还不太了解的可以先移步上一篇。本篇从libbpf-bootstrap下的minimal例子入手，学习libbpf的代码风格及eBPF编程中的一些规则和定义，并对基于eBPF实现的容器日志取证系统ProvBPF进行了复现分析。</p><span id="more"></span><h2 id="一、Minimal-app"><a href="#一、Minimal-app" class="headerlink" title="一、Minimal app"></a>一、Minimal app</h2><p>minimal app示例包括内核程序minimal.bpf.c和用户程序minimal.c。</p><h3 id="1-1-minimal-bpf-c"><a href="#1-1-minimal-bpf-c" class="headerlink" title="1.1 minimal.bpf.c"></a>1.1 minimal.bpf.c</h3><p>内核代码编程中的一些规则：<br></p><blockquote><ul><li>BPF代码可以读取和更新全局变量，就像其他用户空间的C代码对待全局变量那样。使用BPF全局变量维护程序的状态很方便，而且性能表现也不错。</li><li>另外，BPF全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。在用额外的设置项配置BPF程序的时候常常会用到它。它也经常用于在内核中的BPF代码和用户侧的控制代码之间传递数据。</li><li>在同一个BPF C程序文件中，可能有多个BPF程序。他们可以是不同类型的，有着不同的 SEC() 宏。例如，你可以用不同的BPF程序追踪不同的系统调用或其他事件（如网络包的处理）。也可以使用相同的SEC()宏来定义多个BPF程序，libbpf会自动处理他们。</li><li>在同一个BPF C代码文件中的所有的BPF程序共享所有的全局状态，例如下面例子中的my_pid变量，如果使用了BPF map，它也是共享的。</li><li>bpf_printk()帮助函数和trace_pipe文件一般不在生产环境中使用，通常是用来辅助BPF程序的debug的，目前还没有BPF的调试工具，所以这种输出调试是目前最方便的调试方法了。</li><li>通过查看&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下的内容可以查看系统中所有可用的跟踪点。查看&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;bpf目录下定义的事件可以查看BPF可用的所有跟踪点。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2020 Facebook */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span>    <span class="comment">//导入了一些基础必要的BPF相关的类型和常量，以便使用内核侧的BPF API，例如BPF helper function flags。头文件&lt;linux/bpf.h&gt;是之后导入bpf_helpers.h这个头文件所必须的前提。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span>    <span class="comment">//bpf_helpers.h 是由libbpf提供的，包含了大多数常用的宏、常量和BPF helper的定义，几乎会在每个BPF应用中用到。</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;    </span><br><span class="line"><span class="comment">// LICENSE变量定义了BPF代码的 license。在内核开发中，明确license是必须的。一些 BPF功能对于不兼容GPL的代码是不可用的。</span></span><br><span class="line"><span class="comment">// 注意特殊的 SEC(&quot;license&quot;) 注解。</span></span><br><span class="line"><span class="comment">// 定义在bpf_helpers.h中的SEC()把变量和函数放到了特殊的段中。SEC(&quot;license&quot;) 和一些其他的段名，是libbpf规定的，只要遵循就好了。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_pid = <span class="number">0</span>;    <span class="comment">// 定义了一个全局变量my_pid。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该段BPF程序会被加载到内核中。</span></span><br><span class="line"><span class="comment">它是由一个普通的C函数定义的，使用SEC()宏放在一个特殊的段中。</span></span><br><span class="line"><span class="comment">段名定义了libbpf程序创建的是什么类型的BPF程序，以及它是附着到内核上哪个地方的。</span></span><br><span class="line"><span class="comment">在这个例子中，我们是定义了一个tracepoint BPF程序，每次用户空间的应用调用了系统调用write()的时候，就会触发它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SEC(<span class="string">&quot;tp/syscalls/sys_enter_write&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_tp</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取了PID（内核术语中的 &quot;TGID&quot; ），它存储在 bpf_get_current_pid_tgid()返回值高32位。</span></span><br><span class="line"><span class="type">int</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; </span><br><span class="line">    <span class="comment">// 查看触发了write()系统调用的进程是否是我们的minimal进程。</span></span><br><span class="line">    <span class="comment">// 全局变量 my_pid 是通过之后的用户空间的代码进行初始化的，它会被初始化成真实的PID值。</span></span><br><span class="line"><span class="keyword">if</span> (pid != my_pid)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bpf_printk就是BPF中的printf(&quot;Hello, world!\n&quot;)。它输出格式化的字符串到/sys/kernel/debug/tracing/trace_pipe，可以sudo从控制台中去查看它的内容。</span></span><br><span class="line">bpf_printk(<span class="string">&quot;BPF triggered from PID %d.\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bpftool会根据bpf字节码文件（xxx.bpf.o）生成对应的skeleton文件——xxx.skel.h。这个文件中包含了关键的函数和结构体。</p><h3 id="1-2-minimal-c"><a href="#1-2-minimal-c" class="headerlink" title="1.2 minimal.c"></a>1.2 minimal.c</h3><p>用户空间代码minimal.c如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span> <span class="comment">// rlimit使用——对进程设置资源限制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/libbpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minimal.skel.h&quot;</span> <span class="comment">// 由bpftool自动生成的文件，它高度抽象了minimal.bpf.c的结构。</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">libbpf_print_fn</span><span class="params">(<span class="keyword">enum</span> libbpf_print_level level, <span class="type">const</span> <span class="type">char</span> *format, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">minimal_bpf</span> *<span class="title">skel</span>;</span> <span class="comment">// bpftool生成到skel文件中，格式都是xxx_bpf。</span></span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bpf程序资源限制</span></span><br><span class="line">        libbpf_set_strict_mode(LIBBPF_STRICT_ALL);</span><br><span class="line">        <span class="comment">// libbpf_set_print() 提供了一个自定义的回调给所有的 libbpf 日志输出。</span></span><br><span class="line">        <span class="comment">// 默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。</span></span><br><span class="line">        libbpf_set_print(libbpf_print_fn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步，打开bpf文件，返回指向xxx_bpf的指针（在.skel中定义）</span></span><br><span class="line">        skel = minimal_bpf__open();</span><br><span class="line">        <span class="keyword">if</span> (!skel) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ensure BPF program only handles write() syscalls from our process */</span></span><br><span class="line">        <span class="comment">// Skeleton 也可以包含可选的 bss、data、rodata 段，从而可以直接从用户空间访问 BPF 全局变量而不必使用额外的系统调用。</span></span><br><span class="line">skel-&gt;bss-&gt;my_pid = getpid();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 第二步，加载及校验bpf程序</span></span><br><span class="line">        err = minimal_bpf__load(skel);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步，附加到指定的hook点</span></span><br><span class="line">        err = minimal_bpf__attach(skel);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to attach BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` &quot;</span></span><br><span class="line">               <span class="string">&quot;to see output of the BPF programs.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该无穷循环确保了BPF程序handle_tp能够一直附着在内核中，直到用户关掉进程，如按下 Ctrl-C。</span></span><br><span class="line">        <span class="comment">// 同时，它还会每秒调用 fprintf(stderr, ...)，从而触发一次 write() 系统调用。通过这种方法，可以通过handle_tp监控内核的内部情况和状态随时间的变化。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">/* trigger our BPF program */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">cleanup:</span><br><span class="line">        minimal_bpf__destroy(skel);</span><br><span class="line">        <span class="keyword">return</span> -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-MakeFile"><a href="#1-3-MakeFile" class="headerlink" title="1.3 MakeFile"></a>1.3 MakeFile</h3><h4 id="1-3-1-源文件名规则"><a href="#1-3-1-源文件名规则" class="headerlink" title="1.3.1 源文件名规则"></a>1.3.1 源文件名规则</h4><p>libbpf-bootstrap 中的 Makefile 和 CMakeList.txt 规定了源文件名的规则：</p><ul><li>1）生成bpf字节码的 bpf 文件以 .bpf.c 结尾。<br></li><li>2）加载bpf字节码的c文件以.c 结尾。<br></li><li>3）上述两个类型文件名的前缀必须相同。</li></ul><h4 id="1-3-2-具体配置"><a href="#1-3-2-具体配置" class="headerlink" title="1.3.2 具体配置"></a>1.3.2 具体配置</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)</span></span><br><span class="line">OUTPUT := .output</span><br><span class="line">CLANG ?= clang</span><br><span class="line">LLVM_STRIP ?= llvm-strip</span><br><span class="line">LIBBPF_SRC := <span class="variable">$(<span class="built_in">abspath</span> ../../libbpf/src)</span></span><br><span class="line">BPFTOOL_SRC := <span class="variable">$(<span class="built_in">abspath</span> ../../bpftool/src)</span></span><br><span class="line">LIBBPF_OBJ := <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(OUTPUT)</span>/libbpf.a)</span></span><br><span class="line">BPFTOOL_OUTPUT ?= <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(OUTPUT)</span>/bpftool)</span></span><br><span class="line">BPFTOOL ?= <span class="variable">$(BPFTOOL_OUTPUT)</span>/bootstrap/bpftool</span><br><span class="line">LIBBLAZESYM_SRC := <span class="variable">$(<span class="built_in">abspath</span> ../../blazesym/)</span></span><br><span class="line">LIBBLAZESYM_OBJ := <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(OUTPUT)</span>/libblazesym.a)</span></span><br><span class="line">LIBBLAZESYM_HEADER := <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(OUTPUT)</span>/blazesym.h)</span></span><br><span class="line">ARCH := <span class="variable">$(<span class="built_in">shell</span> uname -m | sed &#x27;s/x86_64/x86/&#x27; | sed &#x27;s/aarch64/arm64/&#x27; | sed &#x27;s/ppc64le/powerpc/&#x27; | sed &#x27;s/mips.*/mips/&#x27;)</span></span><br><span class="line">VMLINUX := ../../vmlinux/<span class="variable">$(ARCH)</span>/vmlinux.h</span><br><span class="line"><span class="comment"># Use our own libbpf API headers and Linux UAPI headers distributed with</span></span><br><span class="line"><span class="comment"># libbpf to avoid dependency on system-wide headers, which could be missing or</span></span><br><span class="line"><span class="comment"># outdated</span></span><br><span class="line">INCLUDES := -I<span class="variable">$(OUTPUT)</span> -I../../libbpf/<span class="keyword">include</span>/uapi -I<span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(VMLINUX)</span>)</span></span><br><span class="line">CFLAGS := -g -Wall</span><br><span class="line">ALL_LDFLAGS := <span class="variable">$(LDFLAGS)</span> <span class="variable">$(EXTRA_LDFLAGS)</span></span><br><span class="line"></span><br><span class="line">APPS = minimal minimal_legacy bootstrap uprobe kprobe fentry usdt sockfilter tc</span><br><span class="line"></span><br><span class="line">CARGO ?= <span class="variable">$(<span class="built_in">shell</span> which cargo)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(CARGO)</span>)</span>,)</span><br><span class="line">BZS_APPS :=</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BZS_APPS := profile</span><br><span class="line">APPS += <span class="variable">$(BZS_APPS)</span></span><br><span class="line"><span class="comment"># Required by libblazesym</span></span><br><span class="line">ALL_LDFLAGS += -lrt -ldl -lpthread -lm</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get Clang&#x27;s default includes on this system. We&#x27;ll explicitly add these dirs</span></span><br><span class="line"><span class="comment"># to the includes list when compiling with `-target bpf` because otherwise some</span></span><br><span class="line"><span class="comment"># architecture-specific dirs will be &quot;missing&quot; on some architectures/distros -</span></span><br><span class="line"><span class="comment"># headers such as asm/types.h, asm/byteorder.h, asm/socket.h, asm/sockios.h,</span></span><br><span class="line"><span class="comment"># sys/cdefs.h etc. might be missing.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use &#x27;-idirafter&#x27;: Don&#x27;t interfere with include mechanics except where the</span></span><br><span class="line"><span class="comment"># build would have failed anyways.</span></span><br><span class="line">CLANG_BPF_SYS_INCLUDES = <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CLANG)</span> -v -E - &lt;/dev/null 2&gt;&amp;1 \</span></span><br><span class="line"><span class="variable">| sed -n &#x27;/&lt;...&gt; search starts here:/,/End of search list./&#123; s| \(/.*\)</span>|-idirafter \1|p &#125;&#x27;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(V)</span>,1)</span><br><span class="line">Q =</span><br><span class="line">msg =</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Q = @</span><br><span class="line">msg = @printf &#x27;  %-8s %s%s\n&#x27;\</span><br><span class="line">      <span class="string">&quot;$(1)&quot;</span>\</span><br><span class="line">      <span class="string">&quot;$(patsubst $(abspath <span class="variable">$(OUTPUT)</span>)/%,%,$(2))&quot;</span>\</span><br><span class="line">      <span class="string">&quot;$(if $(3), $(3))&quot;</span>;</span><br><span class="line">MAKEFLAGS += --no-print-directory</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> allow-override</span><br><span class="line">  <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">or</span> $(<span class="built_in">findstring</span> environment,$(<span class="built_in">origin</span> $(1)</span>)),\</span><br><span class="line">            <span class="variable">$(<span class="built_in">findstring</span> command line,$(<span class="built_in">origin</span> $(1)</span>))),,\</span><br><span class="line">    <span class="variable">$(<span class="built_in">eval</span> $(1)</span> = $(2)))</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> allow-override,CC,<span class="variable">$(CROSS_COMPILE)</span>cc)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> allow-override,LD,<span class="variable">$(CROSS_COMPILE)</span>ld)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: <span class="variable">$(APPS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,CLEAN)</span></span><br><span class="line"><span class="variable">$(Q)</span>rm -rf <span class="variable">$(OUTPUT)</span> <span class="variable">$(APPS)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span> <span class="variable">$(OUTPUT)</span>/libbpf <span class="variable">$(BPFTOOL_OUTPUT)</span>:</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,MKDIR,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span>mkdir -p <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build libbpf</span></span><br><span class="line"><span class="variable">$(LIBBPF_OBJ)</span>: <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LIBBPF_SRC)</span>/*.[ch] <span class="variable">$(LIBBPF_SRC)</span>/Makefile)</span> | <span class="variable">$(OUTPUT)</span>/libbpf</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,LIB,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> -C <span class="variable">$(LIBBPF_SRC)</span> BUILD_STATIC_ONLY=1      \</span><br><span class="line">    OBJDIR=<span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>/libbpf DESTDIR=<span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>      \</span><br><span class="line">    INCLUDEDIR= LIBDIR= UAPIDIR=      \</span><br><span class="line">    install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build bpftool</span></span><br><span class="line"><span class="variable">$(BPFTOOL)</span>: | <span class="variable">$(BPFTOOL_OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,BPFTOOL,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> ARCH= CROSS_COMPILE= OUTPUT=<span class="variable">$(BPFTOOL_OUTPUT)</span>/ -C <span class="variable">$(BPFTOOL_SRC)</span> bootstrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(LIBBLAZESYM_SRC)</span>/target/release/libblazesym.a::</span><br><span class="line"><span class="variable">$(Q)</span>cd <span class="variable">$(LIBBLAZESYM_SRC)</span> &amp;&amp; <span class="variable">$(CARGO)</span> build --features=cheader --release</span><br><span class="line"></span><br><span class="line"><span class="variable">$(LIBBLAZESYM_OBJ)</span>: <span class="variable">$(LIBBLAZESYM_SRC)</span>/target/release/libblazesym.a | <span class="variable">$(OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,LIB, <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span>cp <span class="variable">$(LIBBLAZESYM_SRC)</span>/target/release/libblazesym.a <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(LIBBLAZESYM_HEADER)</span>: <span class="variable">$(LIBBLAZESYM_SRC)</span>/target/release/libblazesym.a | <span class="variable">$(OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,LIB,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span>cp <span class="variable">$(LIBBLAZESYM_SRC)</span>/target/release/blazesym.h <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build BPF code</span></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.bpf.o: %.bpf.c <span class="variable">$(LIBBPF_OBJ)</span> <span class="variable">$(<span class="built_in">wildcard</span> %.h)</span> <span class="variable">$(VMLINUX)</span> | <span class="variable">$(OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,BPF,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(CLANG)</span> -g -O2 -target bpf -D__TARGET_ARCH_<span class="variable">$(ARCH)</span> <span class="variable">$(INCLUDES)</span> <span class="variable">$(CLANG_BPF_SYS_INCLUDES)</span> -c <span class="variable">$(<span class="built_in">filter</span> %.c,<span class="variable">$^</span>)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(LLVM_STRIP)</span> -g <span class="variable">$@</span> <span class="comment"># strip useless DWARF info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate BPF skeletons</span></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.skel.h: <span class="variable">$(OUTPUT)</span>/%.bpf.o | <span class="variable">$(OUTPUT)</span> <span class="variable">$(BPFTOOL)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,GEN-SKEL,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(BPFTOOL)</span> gen skeleton <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build user-space code</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(OUTPUT)</span>/%.o,<span class="variable">$(APPS)</span>)</span>: %.o: %.skel.h</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.o: %.c <span class="variable">$(<span class="built_in">wildcard</span> %.h)</span> | <span class="variable">$(OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,CC,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c <span class="variable">$(<span class="built_in">filter</span> %.c,<span class="variable">$^</span>)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %,<span class="variable">$(OUTPUT)</span>/%.o,<span class="variable">$(BZS_APPS)</span>)</span>: <span class="variable">$(LIBBLAZESYM_HEADER)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BZS_APPS)</span>: <span class="variable">$(LIBBLAZESYM_OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build application binary</span></span><br><span class="line"><span class="variable">$(APPS)</span>: %: <span class="variable">$(OUTPUT)</span>/%.o <span class="variable">$(LIBBPF_OBJ)</span> | <span class="variable">$(OUTPUT)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> msg,BINARY,<span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> <span class="variable">$(ALL_LDFLAGS)</span> -lelf -lz -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete failed targets</span></span><br><span class="line"><span class="section">.DELETE_ON_ERROR:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># keep intermediate (.skel.h, .bpf.o, etc) targets</span></span><br><span class="line"><span class="section">.SECONDARY:</span></span><br></pre></td></tr></table></figure><h2 id="二、ProveBPF复现"><a href="#二、ProveBPF复现" class="headerlink" title="二、ProveBPF复现"></a>二、ProveBPF复现</h2><ul><li>论文名称：《Secure Namespaced Kernel Audit for Containers》<br></li><li>一句话概括论文的核心思路：将eBPF程序附加到cgroup和LSM交汇处，进而实现容器级的审计记录。<br></li><li>论文源码地址：<a href="https://github.com/saBPF-project/provbpf">https://github.com/saBPF-project/provbpf</a></li></ul><h3 id="2-1-环境复现"><a href="#2-1-环境复现" class="headerlink" title="2.1 环境复现"></a>2.1 环境复现</h3><h4 id="2-1-1-环境说明"><a href="#2-1-1-环境说明" class="headerlink" title="2.1.1 环境说明"></a>2.1.1 环境说明</h4><p><img src="/assets/blog/eBPF2-1.jpg" alt="Alt text"><br></p><center>图来自源码readme</center><ul><li>作者为了防止不同发行版中内核代码改变带来的影响，给了一个初始环境的Vagrant文件，并在该虚拟机环境上编译SaBPF内核，将编译后的内核环境作为ProvBPF代码的初始环境。<br></li><li>只需要make prepare就能根据作者写好的环境依赖安装所需的camflow和libbpf。<br></li></ul><h4 id="2-1-2-安装过程中注意事项"><a href="#2-1-2-安装过程中注意事项" class="headerlink" title="2.1.2 安装过程中注意事项"></a>2.1.2 安装过程中注意事项</h4><ul><li>在执行ruby update_commit时记得先git init。</li><li>saBPF-kernel只是作为安装了相关依赖的环境，具体的容器级审计的实现程序主要见provbpf的分析。</li></ul><h3 id="2-2-代码分析"><a href="#2-2-代码分析" class="headerlink" title="2.2 代码分析"></a>2.2 代码分析</h3><p>整个代码分析思路先从Makefile文件入手，根据执行调用的命令依次分析。同时，可通过<a href="https://elixir.bootlin.com/linux/v5.11.2/source/include/uapi/linux/bpf.h#L94">https://elixir.bootlin.com/linux/v5.11.2/source/include/uapi/linux/bpf.h#L94</a> 和 <a href="https://man7.org/linux/man-pages/man2/bpf.2.html">https://man7.org/linux/man-pages/man2/bpf.2.html</a> 这两个链接查看相关BPF辅助函数的使用和定义。</p><h4 id="2-2-1-Makefile"><a href="#2-2-1-Makefile" class="headerlink" title="2.2.1 Makefile"></a>2.2.1 Makefile</h4><p>根据readme中给出的编译步骤：</p><ul><li>1）make btf：内核头文件生成。由于内核已经支持了BTF，不再需要引入众多的内核头文件来获取内核数据结构的定义，取而代之的是一个通过bpftool生成的vmlinux.h头文件。因此，该步骤使用bpftool生成内核数据结构定义头文件。<br></li><li>2）make kern：使用clang将eBPF程序kern.c编译为BPF字节码provbpf.o。<br></li><li>3）make skel：使用bpftool从编译好的eBPF对象文件中生成用户态空间代码调用的头文件provbpf.skel.h。<br></li><li>4）make usr：编译用户态程序utils.c、types.c、spade.c、w3c.c、record.c、configuration.c、id.c、service.c，得到应用程序provbpfd。<br></li><li>5）make install：拷贝一些应用程序运行时的配置文件并允许使用provbpfd应用程序。<br></li><li>6）make start：开启provbpfd服务。<br></li><li>7）make run：运行provbpfd服务，日志记录在tmp目录下的日志文件中。<br></li></ul><h4 id="2-2-2-kern-c"><a href="#2-2-2-kern-c" class="headerlink" title="2.2.2 kern.c"></a>2.2.2 kern.c</h4><p>在内核LSM的Hook点处增加了一些记录相关事件值的eBPF程序。</p><h4 id="2-2-3-用户态程序"><a href="#2-2-3-用户态程序" class="headerlink" title="2.2.3 用户态程序"></a>2.2.3 用户态程序</h4><p>在内核态就已经将拦截到的数据按照对应结构体进行了map的映射存储，用户态进行了对应的元素记录。</p><h3 id="2-3-复现结果"><a href="#2-3-复现结果" class="headerlink" title="2.3 复现结果"></a>2.3 复现结果</h3><p>如下图，对比了wget操作下camflow和ProvBPF记录的日志情况。其中，ProvBPF将调用的库的源也记录了下来。（通过eBPF程序，可以拦截并记录自己想要的安全数据源）<br><img src="/assets/blog/eBPF2-2.png" alt="Alt text"><br></p><center>复现日志记录对比</center><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://forsworns.github.io/zh/blogs/20210627/">博客文章——使用 libbpf-bootstrap 构建 BPF 程序</a></li><li><a href="https://blog.csdn.net/qq_40711766/article/details/127288536">博客文章——从零构建libbpf+ebpf CO-RE程序</a></li><li><a href="https://www.bilibili.com/video/BV1Hd4y1o72L?share_source=copy_web&vd_source=28532461e369234a7808585e999e9e49">B站视频——Linux内核调试追踪技术</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章中介绍了eBPF初步学习的相关基础知识点，对eBPF开发环境还不太了解的可以先移步上一篇。本篇从libbpf-bootstrap下的minimal例子入手，学习libbpf的代码风格及eBPF编程中的一些规则和定义，并对基于eBPF实现的容器日志取证系统ProvBPF进行了复现分析。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="eBPF" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF初步学习</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/</id>
    <published>2022-08-28T12:37:31.000Z</published>
    <updated>2022-10-21T02:36:51.115Z</updated>
    
    <content type="html"><![CDATA[<p>2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让<strong>操作系统内核可编程化</strong>，成为云原生时代软件系统的一把利刃。</p><span id="more"></span><h2 id="一、eBPF概念"><a href="#一、eBPF概念" class="headerlink" title="一、eBPF概念"></a>一、eBPF概念</h2><ul><li>BPF：Berkeley Packet Filter，伯克利包过滤器。<br></li><li>发明之初被称为cBPF（classic BPF），是一款网络过滤神器，衍生工具有tcpdump等。<br></li><li>发展演进成一套通用执行引擎eBPF（extended Berkeley Packet Filter），不再仅仅是网络分析，还可以基于eBPF开发性能分析、系统追踪、网络优化等多种类型的工具和平台。<br></li></ul><h3 id="1-1-为什么需要BPF"><a href="#1-1-为什么需要BPF" class="headerlink" title="1.1 为什么需要BPF"></a>1.1 为什么需要BPF</h3><p>过去的程序为了分析只在内核空间运行的数据，必须将数据从内核空间复制到用户空间的内存中去，并进行上下文切换。而这与直接在内核空间分析数据相比，产生了巨大的性能开销。随着近年来网络速度和流量的快速增长（音频、视频流媒体数据），在用户空间监控分析那么多的流量数据已经不可行了，一种在内核空间执行高效安全的程序的机制BPF就应运而生了。<br><br>1992年，《The BSD Packet Filter: A New Architecture for User-level Packet Capture》论文中第一次提出BPF技术，文中描述了如何在Unix内核实现网络数据包过滤，比当时的数据包过滤技术快20倍。<br></p><h3 id="1-2-BPF内核编程的好处"><a href="#1-2-BPF内核编程的好处" class="headerlink" title="1.2 BPF内核编程的好处"></a>1.2 BPF内核编程的好处</h3><p>传统的Linux内核开发需要实现强安全、高性能和持续交付。<br><br>现有的方案存在以下问题：</p><ul><li>1）直接修改内核代码——&gt;内核版本更新满，每次功能更新都需要重新编译打包内核代码；<br></li><li>2）开发新的可即时加载的内核模块，用户可以在运行时加载到Linux内核中进而扩展内核功能——&gt;内核模块需要跟着内核版本的更新进行调整，此外还存在让内核crash的风险。<br></li></ul><p>BPF通过BPF验证器、JIT编译器和用户空间可编程三个特性实现了内核开发的需求：</p><ul><li>1）强安全：BPF验证器（verifier）会检查将要运行到内核空间的程序的每一行是否安全可靠，如果检查不通过，它将拒绝这个程序被加载到内核中去，从而保证内核本身不会崩溃<em>（这是不同于开发内核模块的）</em>。<br></li><li>2）高性能：Just-In-Time（指令即时翻译）编译器保证了程序本地运行的高性能。<br></li><li>3）持续交付：可以在不影响系统运行的情况下，实时在线地替换这些运行在Linux内核中的eBPF程序。<br></li></ul><h3 id="1-3-eBPF架构"><a href="#1-3-eBPF架构" class="headerlink" title="1.3 eBPF架构"></a>1.3 eBPF架构</h3><p>介绍：用户把eBPF程序编译为eBPF指令，然后通过bpf()系统调用将eBPF指令加载到内核的特定挂载点，由特定的事件来触发eBPF指令的执行。在挂载eBPF指令时内核会进行充分验证，避免eBPF代码影响内核的安全和稳定性。另外内核也会进行JIT编译，把eBPF指令翻译为本地指令，减少性能开销。<br></p><p><img src="/assets/blog/eBPF-1.jpg" alt="Alt text"><br></p><center>图来自https://www.ebpf.top/post/ebpf_intro/</center><p>eBPF用户空间程序和内核中的BPF字节码交互流程如下：</p><ul><li>1）用户自定义程序，使用LLVM或GCC工具将编写的BPF代码程序编译成BPF字节码。<br></li><li>2）字节码被装载到内核VM中，基于类RISC指令的VM运行在内核空间。<br></li><li>3）其中，字节码通过BPF Verifier确保内核安全。<br></li><li>4）验证后的字节码通过BPF JIT机制转成内核可执行的本地指令运行。<br></li></ul><p>上述流程中涉及到的程序的装载过程具体是：通过<strong>bpf()系统调用</strong>将eBPF程序装载到内核中，其中包含多种bpf命令，用于用户空间与内核VM交互。<br>注意：BPF程序不是以机器指令加载到内核的，而是以字节码形式加载到内核中的。</p><p><img src="/assets/blog/eBPF-2.jpg" alt="Alt text"><br></p><p>上述流程中涉及到的程序验证具体是：保证程序的安全执行，不破坏内核。主要验证程序的权限、程序不能对内核有损害、程序能够结束（循坏有限）等。<br><br>eBPF是事件驱动的，当内核或应用程序通过某个挂钩点时运行。预定义的钩子包括系统调用、函数入口&#x2F;出口、内核跟踪点、网络事件和其他钩子。<br></p><p><img src="/assets/blog/eBPF-3.jpg" alt="Alt text"><br></p><center>图来自(eBPF概念及在可观测性、网络、安全和优化领域的应用)</center><p>内核中运行的BPF字节码程序可以使用两种方式将测量数据回传至用户空间：<br></p><ul><li>1）eBPF maps，被设计成 key&#x2F;value 的形式，能够在用户态程序与内核态eBPF程序之间进行双向通信。<br></li><li>2）perf-event 用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析。<br></li></ul><h2 id="二、eBPF编程"><a href="#二、eBPF编程" class="headerlink" title="二、eBPF编程"></a>二、eBPF编程</h2><p>BPF开发工具总结如下图，这里笔者主要使用bpftrace和libbpf-bootstrap进行内核跟踪的开发实践。<br><br><img src="/assets/blog/eBPF-4.jpg" alt="Alt text"><br></p><h3 id="2-1-bpftrace实践"><a href="#2-1-bpftrace实践" class="headerlink" title="2.1 bpftrace实践"></a>2.1 bpftrace实践</h3><p>bpftrace在eBPF和BCC之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的跟踪功能。</p><blockquote><p>安装bpftrace参考：<a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md">https://github.com/iovisor/bpftrace/blob/master/INSTALL.md</a> 。<br>若未正确安装可能会出现“lockdown is enabled and set to ‘confidentiality’”报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l &#x27;*execve*&#x27;</span><br><span class="line">sudo bpftrace -l ｜grep execve</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这些函数可以分为 tracepoint（内核静态探针），kprobe（内核态动态函数探针）和 kfunc （基于BPF的内核态动态函数探针）三类。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kfunc，kprobe属于不稳定接口，而tracepoint则是稳定接口。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因而，优先选择更稳定的跟踪点，以保证 eBPF 程序的可移植性（即在不同版本的内核中都可以正常执行）。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-5.jpg" alt="Alt text"><br></p><h4 id="2-1-1-tracepoint跟踪"><a href="#2-1-1-tracepoint跟踪" class="headerlink" title="2.1.1 tracepoint跟踪"></a>2.1.1 tracepoint跟踪</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪系统调用execve查看入口参数</span></span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_exit_execve &#123; printf(&quot;%-6d %-8s ret=%d \n&quot;,pid,comm,args-&gt;ret); &#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123; printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bpftrace -e ：表示直接从后面的字符串参数中读入bpftrace程序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tracepoint:syscalls:sys_enter_execve表示跟踪的函数，如果多个函数可以用逗号分隔，后面&#123;&#125;中表示跟踪点的处理函数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理函数如：<span class="built_in">printf</span>()表示向终端中打印字符串，其用法就是C语言中的<span class="built_in">printf</span>()函数。其中pid和<span class="built_in">comm</span>是bpftrace内置的变量，分别表示进程PID和进程名称。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-6.jpg" alt="Alt text"><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还可以写成脚本的形式：vim jiaoben.bt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bpftrace</span></span><br><span class="line">tracepoint:syscalls:sys_enter_execve </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 sudo ./jiaoben.bt 即可达到上述命令行效果</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-kprobe监控"><a href="#2-1-2-kprobe监控" class="headerlink" title="2.1.2 kprobe监控"></a>2.1.2 kprobe监控</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核动态探针kprobe监控内核函数vfs_open的跟踪点和入口参数</span></span><br><span class="line">sudo bpftrace -lv kfunc:vfs_open</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核函数的调用栈</span></span><br><span class="line">sudo bpftrace -e &#x27;kprobe:vfs_open &#123; @[kstack(perf)] = count(); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-7.jpg" alt="Alt text"><br></p><h4 id="2-1-3-用户态函数探针检测"><a href="#2-1-3-用户态函数探针检测" class="headerlink" title="2.1.3 用户态函数探针检测"></a>2.1.3 用户态函数探针检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用用户态函数探针 uprobe和uprobe检测用户态的程序test</span></span><br><span class="line"><span class="comment">// 编写test.c文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成test应用程序：gcc -g test.c -o test</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用bpftrace跟踪<span class="built_in">test</span>程序的main函数，输出参数个数、第1个参数和返回值：</span></span><br><span class="line">sudo bpftrace -e &#x27;uprobe:/home/jian/Desktop/bpf/third/test:main &#123;printf(&quot;count:%d  &quot;,arg0);join(arg1)&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/home/jian/Desktop/bpf/third/test:main &#123; printf(&quot;test main return %d\n&quot;, retval); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用用户态函数探针 uretprobe检测开源应用程序bash</span></span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/usr/bin/bash:readline &#123; printf(&quot;User %d executed \&quot;%s\&quot; command\n&quot;, uid, str(retval)); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-8.jpg" alt="Alt text"><br></p><h4 id="2-1-4-事件检测"><a href="#2-1-4-事件检测" class="headerlink" title="2.1.4 事件检测"></a>2.1.4 事件检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针Software检测软件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;s:*&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;software:page-faults:100 &#123; @[comm] = count(); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针hardware检测硬件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;h:*&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟机环境不支持</span></span><br></pre></td></tr></table></figure><h3 id="2-2-libbpf实践"><a href="#2-2-libbpf实践" class="headerlink" title="2.2 libbpf实践"></a>2.2 libbpf实践</h3><p>BCC依赖于LLVM和内核头文件才可以动态编译和加载eBPF程序，然而，很多环境中通常没有甚至不允许安装这些开发工具。其中一种解决方案就是使用libbpf来开发一个eBPF程序。<br></p><blockquote><p>首先需要知道，一个以开发BPF程序为目的的工程通常由两类源文件组成：</p><ul><li>一类是运行于内核态的BPF程序的源代码文件.</li><li>另外一类是用于向内核加载BPF程序、从内核卸载BPF程序、与内核态进行数据交互、展现用户态程序逻辑的用户态程序的源代码文件。</li></ul></blockquote><h4 id="2-2-1-基于libbpf-bootstrap项目的实现"><a href="#2-2-1-基于libbpf-bootstrap项目的实现" class="headerlink" title="2.2.1 基于libbpf-bootstrap项目的实现"></a>2.2.1 基于libbpf-bootstrap项目的实现</h4><p>内核BPF开发者Andrii Nakryiko在github上开源了一个直接基于libbpf开发BPF程序与加载器的引导项目libbpf-bootstrap，这个项目中包含使用c和rust开发BPF程序和用户态程序的例子。下图是基于libbpf-bootstrap实现的hello world程序实例的示意图。</p><p><img src="/assets/blog/eBPF-9.jpg" alt="Alt text"><br></p><center>图来自参考链接“使用C语言...eBPF程序”</center><ul><li>图中的libbpf其实是指linux内核代码库中的tools&#x2F;lib&#x2F;bpf，是内核提供给外部开发者的C库，用于创建BPF用户态的程序。<br></li><li>图中的bpftool对应的是linux内核代码库中的tools&#x2F;bpf&#x2F;bpftool，是一个bpf辅助工具，在libbpf-bootstrap中用于生成xx.skel.h。（在eBPF程序中，由于内核已经支持了BPF，因此不再需要引入众多的内核头文件来获取内核数据结构的定义。取而代之的是一个通过bpftool生成的vmlinux.h头文件——也就是xx.skel.h，其中包含了内核数据结构的定义。<br></li><li>helloworld.bpf.c是bpf程序对应的源码，通过clang -target&#x3D;bpf编译成BPF字节码ELF文件helloworld.bpf.o。<br></li><li>libbpf-bootstrap并没有使用用户态加载程序直接去加载helloworld.bpf.o，而是通过bpftool gen命令基于helloworld.bpf.o生成helloworld.skel.h文件，在生成的helloworld.skel.h文件中包含了BPF程序的字节码以及加载、卸载对应BPF程序的函数，我们在用户态程序直接调用即可。<br></li><li>helloworld.c是BPF用户态程序，它只需要include helloworld.skel.h并按套路加载、挂接BPF程序到内核层对应的埋点即可。由于BPF程序内嵌到用户态程序中，我们在分发BPF程序时只需分发用户态程序即可！<br></li></ul><p>结合上述流程分析，基于libbpf-bootstrap的eBPF程序的开发流程如下：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装依赖</span></span><br><span class="line">sudo apt-get install make clang llvm libelf-dev pkg-config gcc binutils-dev libcap-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.下载libbpf-bootstrap</span></span><br><span class="line">git clone https://github.com/libbpf/libbpf-bootstrap.git</span><br><span class="line">cd libbpf-bootstrap/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.初始化和更新libbpf-bootstrap的依赖</span></span><br><span class="line">cat .gitmodules</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.基于libbpf-bootstrap框架的BPF程序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入libbpf-bootstrap/examples/c目录下，在该目录下创建两个C源文件helloworld.bpf.c和helloworld.c(参考了minimal.bpf.c和minimal.c)，显然前者是运行在内核态的BPF程序的源码，而后者则是用于加载BPF到内核的用户态程序。</span></span><br><span class="line">cd examples/c</span><br><span class="line">sudo make minimal</span><br><span class="line">sudo ./minimal</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/trace_pipe</span><br></pre></td></tr></table></figure><h4 id="2-2-2-基于libbpf的独立实现"><a href="#2-2-2-基于libbpf的独立实现" class="headerlink" title="2.2.2 基于libbpf的独立实现"></a>2.2.2 基于libbpf的独立实现</h4><p>使用libbpf开发eBPF程序也是需要内核态的eBPF程序和用户态的加载、挂载、映射读取以及输出程序的，步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装libbpf库和bpftool工具。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.在任意路径下建立一个helloworld目录，将前面的helloworld.bpf.c和helloworld.c拷贝到该helloworld目录下。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.编写Makefile。整个Makefile的构建过程与libbpf-bootstrap中的Makefile异曲同工，同样是先编译bpf字节码，然后生成内核头文件helloworld.skel.h。最后编译依赖helloworld.skel.h的helloworld程序。</span></span><br></pre></td></tr></table></figure><h2 id="三、推荐学习路径"><a href="#三、推荐学习路径" class="headerlink" title="三、推荐学习路径"></a>三、推荐学习路径</h2><p>参考狄卫华老师推荐的<a href="">eBPF学习路径</a>，结合自身的学习情况，整理了一些对个人帮助较大的博客和资料，按照不同阶段的学习需求总结如下：</p><h3 id="3-1-了解eBPF发展背景和相关概念"><a href="#3-1-了解eBPF发展背景和相关概念" class="headerlink" title="3.1 了解eBPF发展背景和相关概念"></a>3.1 了解eBPF发展背景和相关概念</h3><ul><li><a href="https://www.ebpf.top/post/ebpf_intro/">博客文章——eBPF技术简介</a></li><li><a href="https://www.bilibili.com/video/BV1PF411V7Lj?share_source=copy_web&vd_source=28532461e369234a7808585e999e9e49">B站视频——陈鹏飞：eBPF概念及在可观测性、网络、安全和优化领域的应用</a></li><li><a href="https://www.youtube.com/watch?v=uBqRv8bDroc&t=2s">Youtube视频——Liz Rice：A Beginner’s Guide to eBPF</a></li></ul><h3 id="3-2-初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解"><a href="#3-2-初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解" class="headerlink" title="3.2 初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解"></a>3.2 初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解</h3><ul><li><a href="https://www.cnblogs.com/lfri/p/15402973.html">博客文章——BPF C编程入门</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123005213">博客文章——使用bpfttrace开发eBEP程序</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123318084">博客文章——使用libbpf开发eBPF程序</a></li><li><a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch/">博客文章——使用C语言从头开发一个Hello World级别的eBPF程序</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210627/">博客文章——使用libbpf-bootstrap构建BPF程序</a></li></ul><h3 id="3-3-穿插书籍阅读，分模块深入"><a href="#3-3-穿插书籍阅读，分模块深入" class="headerlink" title="3.3 穿插书籍阅读，分模块深入"></a>3.3 穿插书籍阅读，分模块深入</h3><ul><li>《Linux内核观测技术BPF》</li></ul><h2 id="四、国内eBPF实践团队"><a href="#四、国内eBPF实践团队" class="headerlink" title="四、国内eBPF实践团队"></a>四、国内eBPF实践团队</h2><ul><li>字节跳动STE团队</li><li>阿里云荣旸</li><li>腾讯云TKE团队</li><li>eBay IE Cloud团队</li><li>网易杭研轻舟云原生</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让&lt;strong&gt;操作系统内核可编程化&lt;/strong&gt;，成为云原生时代软件系统的一把利刃。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="eBPF" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>新的学期，新的生活</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2019/09/10/life-1-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2019/09/10/life-1-md/</id>
    <published>2019-09-10T09:00:08.000Z</published>
    <updated>2023-02-11T05:07:16.209Z</updated>
    
    <content type="html"><![CDATA[<p>开学也一周多了，这里记录一下最近的感受。<br><br>前几天回所和导师们聊天了，收获颇丰，也深刻地感受到了研究生阶段与本科生阶段求学生涯的重大区别。十分感谢徐老师抽出时间和我聊了那么久，前人的经验与建议往往能给开学之初迷茫的我带来很多帮助。这里记录一下老师的教导，也时刻提醒着自己在新的起点要更加努力。</p><span id="more"></span><p>一要学会主动。不管是技能的获得还是资源的寻找，都要自己主动地去争取。没有人有责任帮助你，你需要学会且习惯去主动地解决自己的问题。且研究生的角色定位更多是导师们的助手，并不是和本科一样完全抱着学习的心态，要找准自己的定位。</br><br>二是发现问题，研究问题，解决问题并总结问题。科研中最大的难点往往是发现问题与解决问题。前者要求你在这个领域这个方向有足够多的研究与深入，才能发现有针对性的有价值的问题。而后者则是对编程等技能的考验。要发现一个有价值的问题需要在这个领域不断深入，广泛地阅读文章，时刻关注该领域的学术动态。</br><br>三是知行合一。所谓知行合一：“知”是指在研究过程中，要注意方法论的积累。科研的方法论需要自己在大量的论文阅读中不断学习总结产生。而“行”则是由于专业的特殊性，在前进过程中避免不了大量的实践与实操，利用自己的知识动手解决问题，而这些都需要自身过硬的技术能力。</br><br>四是对自己高要求。本科时听闻我直博的消息，高老师还曾和我细聊了很久，问及我的想法与计划。当时的我也比较迷茫，只想着提升学历再加上父母也比较支持，就一直没有细细思索过自己直博的真正目的。可不管如何，进入了博士阶段，就要付出自己的努力，好好做科研不断提升技能能力。既然已经决定把自己六年的青春年华留在这里，就要让自己过得值。你想毕业后成为怎样的人，你就必然要付出对应的努力，才能给自己提交一份满意的答卷。（在我的学习道路上遇到了太多好老师，真的十分幸运且心怀感激，在我迷茫之际给了我很多指导与帮助。）</br><br>同时，这几天的课堂生活也让我感触颇多。首先是学会时间管理和作息调整。原来习惯午睡的我在每天满课的状态下根本没法儿维持这个作息了，甚至于有两天午饭时间都十分紧张。还是希望自己能尽快调整好作息，好好管理自己在雁西湖校区的这一年学习时间。其次还是身体问题，原来的时候不注意，这两个月来腰部的疼痛已经严重困扰了我的学习和生活。现在不贴膏药根本无法支撑一天从上午八点到晚上九点四十的坐着的学习生活（感觉自己活成了老年人）。坐了一节课腰部就十分难受，腰肌劳损还是很影响学习和生活的。还是要尽快形成规律的锻炼时间，好好保护自己的身体。</br><br>全篇鸡汤很多但重点也很多，新的学期，新的开始，希望自己能不负韶华，好好努力！！！冲鸭～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学也一周多了，这里记录一下最近的感受。&lt;br&gt;&lt;br&gt;前几天回所和导师们聊天了，收获颇丰，也深刻地感受到了研究生阶段与本科生阶段求学生涯的重大区别。十分感谢徐老师抽出时间和我聊了那么久，前人的经验与建议往往能给开学之初迷茫的我带来很多帮助。这里记录一下老师的教导，也时刻提醒着自己在新的起点要更加努力。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/life/"/>
    
    
    <category term="feeling" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/feeling/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 本地提权漏洞（CVE-2017-16995）</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/</id>
    <published>2018-03-22T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Ubuntu 16.04.1~16.04.4<br>Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）</p><span id="more"></span><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>该漏洞存在于调用eBPF bpf(2)的Linux内核系统中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题， 低权限用户可使用此漏洞获得管理权限。</p><blockquote><p>eBPF - extended Berkeley Packet Filter<br>  简单理解就是用于过滤网络数据包。</p></blockquote><p>EXP下载链接：<a href="https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip">https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip</a></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本来刚开始打算虚拟机复现的，结果安装完发现下的是内核版本为GNU&#x2F;Linux 4.13.0-37-generic x86_64的Ubuntu 16.04，就很难受😣。<br>于是利用i春秋的实验平台复现了一下，结果如下：<br><img src="/assets/blog/1.png" alt="Alt text"></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>Ubuntu 官网暂时没有提供修复方案，可以在评估风险后通过修改内核参数限制普通用户使用 bpf(2) 系统调用来临时修复此漏洞。<br><img src="/assets/blog/2.png" alt="Alt text"></p><blockquote><p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;unprivileged_bpf_disabled</p></blockquote><p>彻底根治方案：更新内核。</p><p>参考链接：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html">eBPF 简史</a><br><a href="https://mp.weixin.qq.com/s/51txDsanj-uSqXdm5GZuEA">i春秋实验</a><br><a href="http://www.yunweipai.com/archives/25298.html">http://www.yunweipai.com/archives/25298.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h4&gt;&lt;p&gt;Ubuntu 16.04.1~16.04.4&lt;br&gt;Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="CVE" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>微信是怎样发送消息的</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/</id>
    <published>2017-12-28T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.009Z</updated>
    
    <content type="html"><![CDATA[<p>从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。</p><p>从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。</p><span id="more"></span><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="/assets/blog/4.png" alt="Alt text">  （图来自课上赵老师）</p><p> 这边首先对数据流量和wifi二者的区别做一个简单介绍：<br>    1、数据流量是通过基站，如果基站覆盖范围大的话，信号接收当然会比wifi好。<br>    2、而wifi是通过wifi接入点（或者简单点理解就是无线路由器），再通过学校交换机，再通过中继器，再通过运营商的路由器。</p><p>手机将文字、图片、语音等数据通过电磁波为载体，在空气中经过上图传播流程后，通过运营商给你接通的讯道传输到对方手机。当手机接收到信号之后再把信号转换，从而实现双方的消息传递。</p><p><em>并没有学过通信原理，这边很多概念也都一知半解，只能浅显地给出自己的一些理解，大佬们轻喷@_@</em></p><h2 id="数据链路层、网络层"><a href="#数据链路层、网络层" class="headerlink" title="数据链路层、网络层"></a>数据链路层、网络层</h2><p>其实在上一段的图中已经提及了，这边也不进一步分析了。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><img src="/assets/blog/5.png" alt="Alt text">    （图来自网络）<br>这边即时通讯关于UDP和TCP的使用区别还是很重要的一个点，也许很多人一听到这个就会下意识地背出“tcp是面向连接的可靠交付，而udp是无连接的不可靠交付”，深入下去其实并不简单。<br>微信既有UDP也有TCP！</p><blockquote><p>UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。微信采用的通信协议以UDP为主，辅以TCP协议。由于微信的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。<br>微信客户端之间的消息传送也采用了UDP模式，因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此微信选择了UDP作为客户之间的主要通信协议。</p></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层这边还是直接看操作吧～</p><p>尝试用wireshark抓包（由于mac微信无法设置代理，也有可能是我还不太熟悉…..这边是对网页版微信的一个抓包）：<br><img src="/assets/blog/6.png" alt="Alt text"><br>先是建立TCP连接：如图前面是TCP的三次握手：<br>    首先客户端向服务器发送标志为SYN的连接请求，数据包标号Seq&#x3D;0；  <br>    收到请求后，服务器向客户端发送了带有SYN和ACK的确认应答，发送序号Seq&#x3D;0，确认序号ACK&#x3D;1；接下来，客户端向服务器发送确认应答，Seq&#x3D;1，ACK&#x3D;1. 连接建立完成。 <br>后面紧跟着的是HTTP数据包，数据最后一行为空行，表明数据已经传送完毕，如下图所示：<br><img src="/assets/blog/7.png" alt="Alt text"><br>发现他的数据通信是http协议的，可是发送数据和返回数据都是加密过的（逆向表哥可以试试跟踪处理过程，web渣表示无能为力）</p><p>除了wireshark，还尝试过进xp系统用fiddler抓包，这里其实抓到的数据更多，但是。。。。。我忘记截图了，就很尴尬😳。后面也试过用神器burpsuite，但可能代理这边一直无法设置，也没有做进一步的改包实验。结合之前看到的一篇论文，这边稍微对抓包后的结果总结一下：<br>1、微信通过内置浏览器和服务器交互数据。 <br>微信在应用层使用HTTP协议传输数据。微信点击网址链接，会跳转到浏览器模式，打开该消息对应的网页。而且用wireshark抓包发现微信的通信都是用HTTP协议收发数据的，内嵌浏览器为网络通信接口。（之前课上和老师争论过关于http和https协议的应用问题，现在想想有点傻，哈哈哈）<br>2、微信的数据用SSL加密传输。</p><p>接下来从其他方面做一个分析（为了凑出老师说好的十个要点我也是很拼了！！！求表扬求发糖&#x3D;-&#x3D;）<br>1、C&#x2F;S通信模式<br><img src="/assets/blog/8.png" alt="Alt text"><br>（图来自书《网络是怎样连接的》，强烈安利）<br>2、p2p对等模式<br>整个网络结构中不存在中心节点（或中心服务器）。在P2P结构中，每一个节点（peer）大都同时具有信息消费者、信息提供者和信息通讯等三方面的功能。<br>3、微信技术是基于即时通信技术原理的一种<br>当前使用的IM系统大都组合使用了C&#x2F;S和P2P模式。在登录IM进行身份认证阶段是工作在C&#x2F;S方式,随后如果客户端之间可以直接通信则使用P2P方式工作，否则以C&#x2F;S方式通过IM服务器通信。<br>4、手机分为电源部分，逻辑部分，射频部分，输入输出部分<br>    首先输入输出部分指的是触摸屏，麦克风，听筒等（手机触摸屏分为两种：电阻屏和电容屏。电阻触屏：需用压力使屏幕各层发生接触。电容触屏：来自带电的手指表层最细微的接触也能激活屏幕下方的电容感应系统。）<br>    逻辑部分是指CPU，字库，暂存等，作用就是控制手机的各项操作。<br>    射频部分就是信号部分，有功放，滤波，中频IC等，管接收和发射，<br>    电源是各元器件的供电。<br>发信息时，按字后根据触摸点在屏幕的坐标位置进行识别，再将字在此时作为输出设备的屏幕上显示。</p><p>计算机组成原理学得比较浅，很多东西的理解都还浮在表面，还是希望自己能再多花时间去学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。&lt;/p&gt;
&lt;p&gt;从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="course" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>记第一次线下赛</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/</id>
    <published>2017-12-11T06:25:08.000Z</published>
    <updated>2022-09-01T06:11:38.802Z</updated>
    
    <content type="html"><![CDATA[<p>今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。</p><h2 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h2><p>attack with defence赛制，也就是ctf线下赛。<br>比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。</p><span id="more"></span><h2 id="比赛环境-网络拓扑图"><a href="#比赛环境-网络拓扑图" class="headerlink" title="比赛环境 网络拓扑图"></a>比赛环境 网络拓扑图</h2><p>计网没学好的后遗症，哇，刚开始一直分不清网段，不知道对手在哪，一脸懵逼简直生无可恋。所以，要分清区段和端口！！！<br>    <img src="/assets/blog/3.png" alt="Alt text"></p><blockquote><p>维护的时候需要连接到本队 GameBox 所在网段上，根据主办方提供的 CTF 账号与密码登录。而与其他队伍的 GameBox 交互时则需要连接到对应的网段里与漏洞程序进行交互。提交 flag 则需要到指定的答题平台上提交。</p></blockquote><h2 id="答案提交形式"><a href="#答案提交形式" class="headerlink" title="答案提交形式"></a>答案提交形式</h2><ol><li>攻破其他选手的GameBox,并在GameBox上寻找flag文件；</li><li>在答题页面上登陆后提交flag；</li><li>比赛提供自动提交flag的接口，接口地址需要使用post方式提交，并需要两个参数：answer和token<br><em>这次比赛就是靠大佬写的脚本批量提交flag，排名蹭蹭往上涨～</em></li><li>flag每轮次刷新。</li></ol><h2 id="“涨姿势”"><a href="#“涨姿势”" class="headerlink" title="“涨姿势”"></a>“涨姿势”</h2><p>来来来，敲黑板，划重点！</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><blockquote><p>比赛开始后第一时间备份服务器中web目录下的文件(&#x2F;var&#x2F;www&#x2F;html)，这是自我审计的基础，也是防止服务器在比赛中出现异常的情况下可以立即恢复到初始状态的先决条件。有的比赛可以提供3次左右的恢复初始设置的机会，有的比赛不提供，所以备份十分重要。<br>    可以用ssh user@hostname命令，也可以用图形化工具xshell等。</p></blockquote><h3 id="找主机"><a href="#找主机" class="headerlink" title="找主机"></a>找主机</h3><pre><code> ‘’nmap –sn 192.168.71.0/24‘’</code></pre><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门。<br>发现后门后，第一时间删除或者注释掉，同时利用这个漏洞发起第一波攻击。</p><h3 id="挂waf"><a href="#挂waf" class="headerlink" title="挂waf"></a>挂waf</h3><p>没看清大佬操作，以后再补0.0</p><h3 id="口令问题"><a href="#口令问题" class="headerlink" title="口令问题"></a>口令问题</h3><blockquote><p>弱口令的问题几乎是必考，比赛开始后，如果发现每个队伍的SSH账号密码都是一样的（某次比赛中都是phpcms、wordpress），需要立即修改口令，如果被其他队伍改了那就gg了。Web后台很有可能存在弱口令，一般都是admin&#x2F;admin,admin&#x2F;123456,test&#x2F;test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p></blockquote><h3 id="文件监控-日志分析"><a href="#文件监控-日志分析" class="headerlink" title="文件监控 日志分析"></a>文件监控 日志分析</h3><p> 除了感知攻击，嘿嘿嘿，最重要的是“抄作业”。<br> 然后一定注意权限！</p><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>常见的cms漏洞要熟悉，然后一般漏洞包括SQL注入、文件包含、文件上传等等。</p><h3 id="关注-Gamebox-状态"><a href="#关注-Gamebox-状态" class="headerlink" title="关注 Gamebox 状态"></a>关注 Gamebox 状态</h3><p>一定要注意关注本队Gamebox状态，后面因为服务器down掉了超级多分，就很蓝瘦。。。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html">https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html</a><br><a href="http://bobao.360.cn/ctf/detail/169.html">http://bobao.360.cn/ctf/detail/169.html</a><br><a href="https://www.t00ls.net/articles-40843.html">https://www.t00ls.net/articles-40843.html</a><br><a href="http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg">http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg</a></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>挺开心的一天下来，虽然刚开始因为没带mac的网线转换头沮丧了很久，但是江sir人真的超好啊（没错，就是我队大佬！），不嫌弃拖后腿的我这个小辣鸡，还陪着我到处跑去买转换头。全程看大佬操作，还超nice的讲解，这波很值啊！明天把环境本地复现再玩玩，具体的比赛“姿势”回头补篇笔记，嘿嘿嘿。然后代码审计、脚本编写很很很重要，一些常见的题目漏洞类型要好好掌握（sql、文件包含、各种rce、文件上传），就酱紫～还是希望能趁着大三上学期再多玩玩多学点，怀挺！</p><p>2017-12-08</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。&lt;/p&gt;
&lt;h2 id=&quot;AWD&quot;&gt;&lt;a href=&quot;#AWD&quot; class=&quot;headerlink&quot; title=&quot;AWD&quot;&gt;&lt;/a&gt;AWD&lt;/h2&gt;&lt;p&gt;attack with defence赛制，也就是ctf线下赛。&lt;br&gt;比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/life/"/>
    
    
    <category term="feeling" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/feeling/"/>
    
  </entry>
  
</feed>
