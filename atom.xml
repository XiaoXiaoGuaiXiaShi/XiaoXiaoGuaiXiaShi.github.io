<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DQQ&#39;s blog</title>
  
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/"/>
  <updated>2023-06-08T06:53:38.388Z</updated>
  <id>https://xiaoxiaoguaixiashi.github.io.git/</id>
  
  <author>
    <name>DQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图神经网络在安全检测上的应用</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2023/05/26/GNN/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2023/05/26/GNN/</id>
    <published>2023-05-26T02:46:53.000Z</published>
    <updated>2023-06-08T06:53:38.388Z</updated>
    
    <content type="html"><![CDATA[<p>本篇从图的一些基础概念开始介绍，参考相关综述及博客文章，总结了图神经网络的算法分类，着重整理了图神经网络在网络安全检测上的相关应用。</p><span id="more"></span><h1 id="一-图论基础"><a href="#一-图论基础" class="headerlink" title="一 图论基础"></a>一 图论基础</h1><ul><li>作为机器学习的一种独特的非欧几里得数据结构（排列不整齐），图分析侧重于节点分类、链接预测和聚类等任务。<br></li><li>图神经网络（gnn）是一种通过在图节点之间传递消息来捕获图之间依赖关系的神经模型。<br></li></ul><h3 id="1-1-图的表示"><a href="#1-1-图的表示" class="headerlink" title="1.1 图的表示"></a>1.1 图的表示</h3><ul><li><strong>邻接矩阵（Adjacency Matrix）</strong>：是一种最基础的图表示方式。假设一个图的节点数量为N，则生成一个N*N的矩阵，矩阵中的值为对应位置节点与节点之间的关系，该矩阵一般用A表示。有权图的邻接表与无权图的唯一区别就是将边的权重代替了原来1的位置。</li></ul><p><img src="/assets/blog/GNN-1.jpg" alt="Alt text"><br></p><center>图截取自bilibli视频：邻接矩阵场景之有权图</center><ul><li><strong>邻接列表</strong>：将一张图以矩阵的形式表示固然非常便于计算，但是对于稀疏的大图非常不友好。而邻接列表的表示方式对于稀疏大图则非常友好。（稀疏矩阵的常用存储格式有COO、CSR、CSC）</li></ul><p><img src="/assets/blog/GNN-2.jpg" alt="Alt text"><br></p><center>图截取自bilibli视频：有向无权图的邻接列表</center><ul><li><strong>边集</strong>：通常用两个头尾节点的索引元组表示一条边。例如头节点是h，尾节点是t，那么这一条有向边就是(h,t)；如果是一条无向边则用一对对称元组表示，即(h,t),(t,h)。对于有权图的，用一个三元组的边集来表示，每个元组中间的数组即代表边的权重。</li></ul><h3 id="1-2-邻居与度"><a href="#1-2-邻居与度" class="headerlink" title="1.2 邻居与度"></a>1.2 邻居与度</h3><ul><li>节点的邻居（neighbor）指的是与该节点在同一边另一端的节点。</li><li>节点的度（degree）指的是该节点邻居的数量。</li><li>有向图的邻居可分为前继邻居和后继邻居，度又可分为入度和出度。</li><li>前继邻居（predecessor）：目标节点作为尾节点时，与它相连的头节点；后继邻居（successor）：目标节点作为头节点时，与它相连的尾节点。</li><li>入度（indegree）：前继邻居的数量；出度（outdegree）：后继邻居的数量。</li></ul><h3 id="1-3-结构特征、节点特征、边特征"><a href="#1-3-结构特征、节点特征、边特征" class="headerlink" title="1.3 结构特征、节点特征、边特征"></a>1.3 结构特征、节点特征、边特征</h3><ul><li>整个图即代表结构特征。</li><li>经常会对图进行嵌入（embedding）操作，由嵌入操作得到的节点向量与边向量也可视为它们的特征。</li><li>图由节点与边组成。对于节点来说，本身带有的属性或由嵌入操作得到的节点向量特征叫做节点特征；对于边同理，边的权重也可视为特征，边特征有时也叫关系特征。</li></ul><h3 id="1-4-路径"><a href="#1-4-路径" class="headerlink" title="1.4 路径"></a>1.4 路径</h3><ul><li>路径的定义：路径是从某一个节点到另一个节点之间经过的边与节点组成的子图，包含头尾节点。</li><li>路径的阶数：一条路径上的边数被称为路径的阶数，例如1-2-4或1-3-4属于二阶路径。 1-2，1-3，1-5属于一阶路径。所以又可把节点2，3，5称为节点1的一阶邻居，节点4称为节点1的二阶邻居。</li><li>任务：基于图的基础推荐方式（基于路径的基础链路预测、图游走算法DeepWalk、Node2Vec：<em>Node2Vec</em>与<em>DeepWalk</em>的区别就是Node2Vec可通过调整方向的参数来控制模型更倾向宽度优先的游走还是深度优先的游走）。</li></ul><h1 id="二-图神经网络"><a href="#二-图神经网络" class="headerlink" title="二 图神经网络"></a>二 图神经网络</h1><h3 id="2-1-常见的图神经网络模型"><a href="#2-1-常见的图神经网络模型" class="headerlink" title="2.1 常见的图神经网络模型"></a>2.1 常见的图神经网络模型</h3><p><img src="/assets/blog/GNN-3.jpg" alt="Alt text"><br></p><center>常见的图神经网络模型</center><ul><li>GCN图卷积网络：GCN全称graph convolutional networks，图卷积网络。GCN与CNN都是特征提取器，不同的是，CNN提取的是张量数据特征，GCN提取的是图结构数据特征。计算过程就是消息传递的过程。</li><li>GAT图注意力网络：GAT(GraphAttentionNetworks)，加入了注意力机制的图神经网络，其消息传递的权重是通过注意力机制得到。</li></ul><h3 id="2-2-图采样"><a href="#2-2-图采样" class="headerlink" title="2.2 图采样"></a>2.2 图采样</h3><ul><li>如果图数据量过大，不可以直接仿照传统深度学习的一样的小批量训练方式。因为普通深度学习中训练样本之间并无依赖，但是图结构的数据中，节点与节点之间有依赖关系。如果随意采样的话， 则破坏了样本之间的关系信息。所以需要专门的图采样方法。</li><li>图采样算法GRAPHSAGE：中心思想是小批量采样原有大图的子图。</li><li>图采样算法PINSAGE：中心思想是采样通过随机游走经过的高频节点生成的子图。</li></ul><h3 id="2-3-GNN模型的一般设计流程"><a href="#2-3-GNN模型的一般设计流程" class="headerlink" title="2.3 GNN模型的一般设计流程"></a>2.3 GNN模型的一般设计流程</h3><ul><li>1）<strong>查找图结构</strong>：找到应用程序中的图架构，结构性情况中的图形结构是显式的，非结构化场景中需要从任务中构建图。</li><li>2）<strong>指定图类型和范围</strong>：图可以分类为有向&#x2F;无向图、同构&#x2F;异构图（节点和边具有不同的类型）、静态&#x2F;动态图（输入特征或图的拓扑结构随时间变化）。当图大到无法被设备存储和处理时，需要考虑一些采样方法。</li><li>3）<strong>设计损失函数</strong>：应该根据任务类型和训练设置来设计损失函数。图学习任务通常有节点级任务、边级任务、图级任务（图级任务包括图分类、图回归和图匹配）三种。图学习任务可以分为监督设置、半监督设置、无监督设置三种训练设置（是否提供标记数据）。</li><li>4）<strong>使用计算模块构建模型</strong>：常用的计算模块有传播模块（用于在节点间传播信息，使聚合的信息能够同时捕获特征信息和拓扑信息）、采样模块（图较大时需要采样）、池化模块（获取高级子图或图表示，提取信息）。典型的GNN模型架构通常将上述计算模块进行组合，通过卷积算子、循环算子、采样模块和跳跃连接在每一层传播信息，然后加入池化模块提取高层信息。</li></ul><h1 id="三-图处理python-API"><a href="#三-图处理python-API" class="headerlink" title="三 图处理python API"></a>三 图处理python API</h1><h3 id="3-1-常用的库推荐"><a href="#3-1-常用的库推荐" class="headerlink" title="3.1 常用的库推荐"></a>3.1 常用的库推荐</h3><ul><li><strong>NetworkX</strong>：最老牌的图处理库，早在2002年就发布了第一版。</li><li>**DGL ( Deep Graph Library )**：亚马逊的图神经网络框架，第一版发布于2018年。基于深度学习框架的图神经网络库，兼容PyTorch、Tensorflow、MxNet。文档：<a href="https://docs.dgl.ai/api/python/dgl.html%E3%80%82">https://docs.dgl.ai/api/python/dgl.html。</a></li><li>**PGL ( Paddle Graph Learning )**：第一版发布于2020年，百度的框架，只兼容百度自家的PaddlePaddle深度学习框架。</li></ul><h3 id="3-2-使用DGL创建同构图"><a href="#3-2-使用DGL创建同构图" class="headerlink" title="3.2 使用DGL创建同构图"></a>3.2 使用DGL创建同构图</h3><p>构建图如下：</p><p><img src="/assets/blog/GNN-4.jpg" alt="Alt text"><br></p><center>图截取自YouTube视频：同构图实例</center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dgl</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">src_node_ids = torch.tensor([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">dst_node_ids = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">graph = dgl.graph((src_node_ids,dst_node_ids))</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"></span><br><span class="line">graph.nodes()</span><br><span class="line"><span class="comment"># 返回节点向量tensor([0,1,2,3,4])</span></span><br><span class="line">graph.edges()</span><br><span class="line"><span class="comment"># 返回(tensor([0,0,0,1,1,2,2,3]),tensor([1,2,4,2,3,3,4,4]))</span></span><br><span class="line">graph.edges(form=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line"><span class="comment"># 返回(tensor([0,0,0,1,1,2,2,3]),tensor([1,2,4,2,3,3,4,4]),tensor([0,1,2,3,4,5,6,7]))，第三个是边id向量（图创建时隐形生成的id，共有8条边）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无向图转换</span></span><br><span class="line">undir_graph = dgl.to_bidirected(graph)</span><br><span class="line"><span class="built_in">print</span>(undir_graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图的数据类型</span></span><br><span class="line">graph.idtype</span><br><span class="line"><span class="comment"># torch.int64（32-bit或者64-bit）</span></span><br><span class="line"><span class="comment"># 节点或边的数量不能超过2^32（0 to 2^32-1，4294967296）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit的图和32-bit图的互相转换</span></span><br><span class="line">graph_32 = graph.<span class="built_in">int</span>()</span><br><span class="line">graph_64 = graph_32.long()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用python iterables和 Numpy数组代替tensors，但是在cpu或gpu上tensors效率更高。</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">src_node_ids = numpy.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">dst_node_ids = numpy.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">graph_np = dgl.graph((src_node_ids,dst_node_ids))</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"><span class="comment"># nodes返回的仍然是tensor向量</span></span><br><span class="line">graph_np.nodes()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个孤立的节点5</span></span><br><span class="line">src_node_ids = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">dst_node_ids = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 孤立的节点id是最大的</span></span><br><span class="line">graph = dgl.graph((src_node_ids,dst_node_ids), num_nodes=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加节点和边特征</span></span><br><span class="line">src_node_ids = torch.tensor([<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">dst_node_ids = torch.tensor([<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">graph = dgl.graph((src_node_ids,dst_node_ids))</span><br><span class="line"><span class="comment"># 四个node，每个node都有一个三维数组的特征向量</span></span><br><span class="line">graph.ndata[<span class="string">&#x27;node_vectors&#x27;</span>] = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">graph.ndata[<span class="string">&#x27;node_vectors&#x27;</span>].shape</span><br><span class="line"><span class="comment"># 五条edge，每条edge都有一个一维的特征值</span></span><br><span class="line">graph.edata[<span class="string">&#x27;edge_weights&#x27;</span>] = torch.tensor([<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>])</span><br><span class="line">graph.edata[<span class="string">&#x27;edge_weights&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-3-使用DGL创建异构图"><a href="#3-3-使用DGL创建异构图" class="headerlink" title="3.3 使用DGL创建异构图"></a>3.3 使用DGL创建异构图</h3><p>构建图如下：</p><p><img src="/assets/blog/GNN-5.jpg" alt="Alt text"><br></p><center>异构图实例：节点有三种类型：用户、电影、导演（不同颜色的圈圈代表不同类型的节点），边的类型包括：watches、directs。</center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;(src_type, edge_type, dst_type):(src_node_id_tensor, dst_node_ids_tensor)&#125;</span></span><br><span class="line">data_dict = &#123;(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;watches&#x27;</span>, <span class="string">&#x27;movie&#x27;</span>): (torch.tensor([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]), torch.tensor([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])),</span><br><span class="line">            (<span class="string">&#x27;director&#x27;</span>, <span class="string">&#x27;directs&#x27;</span>, <span class="string">&#x27;movie&#x27;</span>): (torch.tensor([<span class="number">0</span>,<span class="number">1</span>]), torch.tensor([<span class="number">1</span>,<span class="number">0</span>]))&#125;</span><br><span class="line">hetero_graph = dgl.heterograph(data_dict)</span><br><span class="line">hetero_graph.ntypes  <span class="comment"># 结果是[&#x27;director&#x27;, &#x27;movie&#x27;, user&#x27;]</span></span><br><span class="line">hetero_graph.nodes(ntype=<span class="string">&#x27;user&#x27;</span>)  <span class="comment"># 结果是tensor([0,1,2])</span></span><br><span class="line">hetero_graph.etypes <span class="comment"># 结果是[&#x27;watches&#x27;, &#x27;directs&#x27;]</span></span><br><span class="line">hetero_graph.edges(etype=<span class="string">&#x27;watches&#x27;</span>)  <span class="comment"># 结果是(tensor([0,0,1,2]),tensor([0,1,0,1]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向图转换</span></span><br><span class="line">bidir_data_dict = &#123;(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;watches&#x27;</span>, <span class="string">&#x27;movie&#x27;</span>): (torch.tensor([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]), torch.tensor([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])),</span><br><span class="line">            (<span class="string">&#x27;movie&#x27;</span>, <span class="string">&#x27;watched_by&#x27;</span>, <span class="string">&#x27;user&#x27;</span>): (torch.tensor([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]), torch.tensor([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])),</span><br><span class="line">            (<span class="string">&#x27;director&#x27;</span>, <span class="string">&#x27;directs&#x27;</span>, <span class="string">&#x27;movie&#x27;</span>): (torch.tensor([<span class="number">0</span>,<span class="number">1</span>]), torch.tensor([<span class="number">1</span>,<span class="number">0</span>])),</span><br><span class="line">            (<span class="string">&#x27;movie&#x27;</span>, <span class="string">&#x27;directed_by&#x27;</span>, <span class="string">&#x27;director&#x27;</span>): (torch.tensor([<span class="number">1</span>,<span class="number">0</span>]), torch.tensor([<span class="number">0</span>,<span class="number">1</span>]))&#125;</span><br><span class="line">bidir_hetero_graph = dgl.heterograph(bidir_data_dict)</span><br><span class="line">total_num_edges = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> etype <span class="keyword">in</span> bidir_hetero_graph.etypes:</span><br><span class="line">    <span class="built_in">print</span>(bidir_hetero_graph.num_edges(etype=etype))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点属性，边属性</span></span><br><span class="line">hetero_graph.ntypes</span><br><span class="line"><span class="comment"># 三个用户，每个用户拥有二维向量特征</span></span><br><span class="line">hetero_graph.ndata[<span class="string">&#x27;node_vector&#x27;</span>] = &#123;<span class="string">&#x27;user&#x27;</span>: torch.ones(<span class="number">3</span>,<span class="number">2</span>), <span class="string">&#x27;movie&#x27;</span>: torch.ones(<span class="number">2</span>,<span class="number">3</span>), <span class="string">&#x27;director&#x27;</span>: torch.ones(<span class="number">2</span>,<span class="number">2</span>)&#125;</span><br><span class="line">hetero_graph.ndata[<span class="string">&#x27;node_vector&#x27;</span>]</span><br><span class="line">hetero_graph.edata[<span class="string">&#x27;edge_weight&#x27;</span>] = &#123;<span class="string">&#x27;watches&#x27;</span>: torch.ones(<span class="number">4</span>,<span class="number">1</span>), <span class="string">&#x27;directs&#x27;</span>: torch.ones(<span class="number">2</span>,<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">del</span> hetero_graph.ndata[<span class="string">&#x27;node_vector&#x27;</span>]</span><br><span class="line">hetero_graph.nodes[<span class="string">&#x27;user&#x27;</span>].data[<span class="string">&#x27;node_vector&#x27;</span>] = torch.ones(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">hetero_graph.edges[<span class="string">&#x27;watches&#x27;</span>].data[<span class="string">&#x27;edge_weight&#x27;</span>] = orch.ones(<span class="number">4</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>Zhou J, Cui G, Hu S, et al. Graph neural networks: A review of methods and applications[J]. AI open, 2020, 1: 57-81.</li><li><a href="https://www.bilibili.com/video/BV1U44y1K7yP/?p=2&spm_id_from=pageDriver&vd_source=fd1b914dfc6ee3c3a12999d7d73492cd">B站视频——合集【图神经网络基础】( 代码DGL版 )</a></li><li><a href="https://www.youtube.com/watch?v=2HRvuaNtq8o&list=PLFxSpHA6xzmxEHLjLxTLtqbNTRcgqDJoW&index=10">Youtube视频——Graph Neural Networks Using DGL</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇从图的一些基础概念开始介绍，参考相关综述及博客文章，总结了图神经网络的算法分类，着重整理了图神经网络在网络安全检测上的相关应用。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="AI" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核函数分析</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2023/02/28/Linux-function-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2023/02/28/Linux-function-md/</id>
    <published>2023-02-28T14:28:22.000Z</published>
    <updated>2023-03-06T13:55:59.397Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了Linux内核源码的结构组成，并进一步分析了容器源码，介绍了Linux中与容器相关的capabilities机制。</p><span id="more"></span><h1 id="一-Linux内核源码整体组成"><a href="#一-Linux内核源码整体组成" class="headerlink" title="一 Linux内核源码整体组成"></a>一 Linux内核源码整体组成</h1><ul><li>现代操作系统一般由进程管理、内存管理、文件系统、驱动程序、网络等组成，Linux内核源码下的各个目录大致对应了这些部分。</li><li>ll &#x2F;usr&#x2F;src&#x2F;linux<blockquote><ul><li>arch：包含了支持的硬件体系结构相关的核心代码。</li><li>block：存储了块设备驱动的相关代码。</li><li>certs：存储了认证和签名的相关代码。</li><li>crypto：存储了内核中常用的加密、压缩等算法的相关代码。</li><li>documentation：内核中常用的协议规范、功能模块等。</li><li>drivers：包含系统中所有的设备驱动，如显卡驱动程序等。</li><li>fs：fs目录中存储了虚拟文件系统相关代码，每个逻辑文件系统在fs下都有对应的目录，如ext2等。</li><li>include：包括了核心的大多数include文件，对于每种支持的体系结构分别有一个子目录。</li><li>init：包含核心启动代码，该初始化代码关联到了内核的各个组件的入口。</li><li>ipc：包含了核心的进程间通讯代码，如信号量、共享内存等。</li><li>io_uring：新的异步IO框架。</li><li>kernel：主要核心代码，包含了进程管理、IRQ中断等模块。</li><li>lib：包含了核心的库代码，存储了C语言标准库的子集相关代码。</li><li>mm：包含了所有的内存管理代码，与具体硬件体系结构相关的内存管理代码位于arch&#x2F;*&#x2F;mm目录。</li><li>net：核心的网络部分代码，每个子目录对应于网络的一个方面。</li><li>samples： 存储了Linux内核参考示例代码。</li><li>scripts：包含用于配置核心的脚本文件。</li><li>security：存储了Linux内核安全模型相关代码。</li><li>sound：存储了声卡驱动相关代码。</li><li>tools：存储了与Linux内核交互相关代码。</li><li>usr：存储了用户打包和内核压缩相关代码。</li><li>virt：存储了kvm虚拟化目录相关实现的代码。</li></ul></blockquote></li></ul><h1 id="二-Linux中与容器相关的函数调用"><a href="#二-Linux中与容器相关的函数调用" class="headerlink" title="二 Linux中与容器相关的函数调用"></a>二 Linux中与容器相关的函数调用</h1><h2 id="2-1-docker容器源码分析"><a href="#2-1-docker容器源码分析" class="headerlink" title="2.1 docker容器源码分析"></a>2.1 docker容器源码分析</h2><p>容器引擎–&gt;containerd High-level 运行时–&gt;runc Low-level 容器运行时。</p><ul><li>1、首先分析容器引擎moby源码：从moby&#x2F;daemon&#x2F;create.go源码中可知，daemon端先进行container create（调用ContainerCreate进一步创建容器——&gt;daemon.create(params, managed)——&gt;daemon.newContainer()），然后对container start进行处理（r.postContainersCreate()——&gt;ContainerStart()——&gt;daemon.containerStart()——&gt;daemon.containerd.Create()——&gt;container.start()），接下里的内容就交给了docker-containerd继续处理。</li><li>2、然后分析容器运行时containerd代码：Container.NewTask——&gt;TaskService()——&gt;Runtime TaskManager Create——&gt;runc.create()。</li><li>3、runc create –&gt; runc init –&gt; runc start，三者关系时序图如下。其中，runc create为runc init做准备工作，runc init很少被直接使用，而是被runc create隐式地调用。<br><img src="/assets/blog/Linux-function-1.jpg" alt="Alt text"><br><center>图来自(参考链接“runc源码分析”)</center></li></ul><p>runc&#x2F;create.go——&gt;runc&#x2F;utils_linux.go中的startContainer——&gt;createContainer——&gt;CreateLibcontainerConfig——&gt;CreateCgroupConfig（创建cgroup资源控制的配置, 传入默认分区, 返回cgroup资源配置）——&gt;runc&#x2F;libcontainer&#x2F;process_linux.go initProcess.start中通知init 进程，设置新的cgroup namespace，执行nsexec进程。</p><ul><li>4、runc经过多次自身调用，历经新旧namespace创建和切换，最后执行entrypoint替换掉runc自身进程。<br><img src="/assets/blog/Linux-function-2.jpg" alt="Alt text"><br><center>跟namespace相关的三个函数：clone()、setns（）、unshare()</center></li></ul><h2 id="2-2-sysdig实现docker跟踪"><a href="#2-2-sysdig实现docker跟踪" class="headerlink" title="2.2 sysdig实现docker跟踪"></a>2.2 sysdig实现docker跟踪</h2><p><img src="/assets/blog/Linux-function-3.jpg" alt="Alt text"><br></p><center>sysdig架构</center><h2 id="2-3-capabilities检查容器权限"><a href="#2-3-capabilities检查容器权限" class="headerlink" title="2.3 capabilities检查容器权限"></a>2.3 capabilities检查容器权限</h2><h3 id="2-3-1-capabilities相关概念"><a href="#2-3-1-capabilities相关概念" class="headerlink" title="2.3.1 capabilities相关概念"></a>2.3.1 capabilities相关概念</h3><p>capabilities可以应用于文件和进程（或线程，Linux 内核不区分进程和线程），文件的capabilities存储在文件的扩展属性中，扩展属性在构建镜像时会被清理掉，所以在容器中基本不需要考虑文件的capabilities。<br>进程的capabilities通过每个进程单独维护的5个capability集合来控制，每个集合中都包含0个或多个capabilities：</p><ul><li>Permitted：进程所能够使用的capabilities的超集；</li><li>Inheritable：进程在执行exec() 统调用时，能够被新的派生进程所继承的capabilities；</li><li>Effective：内核对进程执行权限检查时所使用的集合；</li><li>Bounding：Inheritable 集合的超集，一个capability 必须在 Bounding 集合中才能添加到Inheritable；</li><li>Ambient：非特权程序执行exec()系统调用时将保留的 capabilities。<br>如内核代码<a href="https://elixir.bootlin.com/linux/v5.18/source/include/linux/cred.h#L110%E4%B8%AD%E6%89%80%E7%A4%BA%EF%BC%9A">https://elixir.bootlin.com/linux/v5.18/source/include/linux/cred.h#L110中所示：</a><br><img src="/assets/blog/Linux-function-4.jpg" alt="Alt text"><br><center>进程结构体中的capability集合</center></li></ul><h3 id="2-3-2-权限检查"><a href="#2-3-2-权限检查" class="headerlink" title="2.3.2 权限检查"></a>2.3.2 权限检查</h3><ul><li>引入capabilities后，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是root，就去检查是否具有该特权操作所对应的capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有capability CAP_KILL；如果设置系统时间，就得具有capability CAP_SYS_TIME。</li><li>capabilities列表见<a href="https://man7.org/linux/man-pages/man7/capabilities.7.html%E3%80%82">https://man7.org/linux/man-pages/man7/capabilities.7.html。</a></li></ul><h3 id="2-3-3-获取和设置capabilities"><a href="#2-3-3-获取和设置capabilities" class="headerlink" title="2.3.3 获取和设置capabilities"></a>2.3.3 获取和设置capabilities</h3><ul><li>系统调用capget(2)和capset(2)，可被用于获取和设置线程自身的capabilities。</li><li>此外，也可以使用libcap中提供的接口cap_get_proc(3)和cap_set_proc(3)。</li><li>如果要查看线程的capabilities，可以通过&#x2F;proc&#x2F;<PID>&#x2F;task&#x2F;<TID>&#x2F;status文件，三种集合分别对应于CapPrm, CapInh和CapEff。但这种的显示结果是数值，不适合阅读。为此，可使用包libcap中的命令getpcaps <PID>获取该进程的主线程的capabilities。</li><li>类似的，如果要查看和设置文件的capabilities，可以使用命令getcap或者setcap。</li><li>Linux源码中对capabilities权限检查的实现在kernel&#x2F;capability.c中。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/375238002">博客文章——Linux内核源代码查看及分析方法</a></li><li><a href="https://guanjunjian.github.io/2017/09/28/study-4-docker-4-postContainersCreate/">博客文章——Docker源码分析</a></li><li><a href="https://juejin.cn/post/6903527508784873485">博客文章——runc源码分析</a></li><li><a href="https://toutiao.io/posts/9t5ta44/preview">博客文章——runc源码分析2</a></li><li><a href="https://www.bilibili.com/read/cv19784745?from=search">博客文章——深究Runc源码-3-Init流程分析</a></li><li><a href="https://waynerv.com/posts/container-fundamentals-permission-control-using-capabilities/">博客文章——容器技术原理(四)：使用 Capabilities 实现权限控制</a></li><li><a href="https://www.ctfiot.com/91844.html">博客文章——Linux Capabilities利用总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了Linux内核源码的结构组成，并进一步分析了容器源码，介绍了Linux中与容器相关的capabilities机制。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="Linux" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF入门</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/</id>
    <published>2022-08-28T12:37:31.000Z</published>
    <updated>2023-04-24T12:58:30.344Z</updated>
    
    <content type="html"><![CDATA[<p>2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让<strong>操作系统内核可编程化</strong>，成为云原生时代软件系统的一把利刃。</p><span id="more"></span><h2 id="一、eBPF概念"><a href="#一、eBPF概念" class="headerlink" title="一、eBPF概念"></a>一、eBPF概念</h2><ul><li>BPF：Berkeley Packet Filter，伯克利包过滤器。<br></li><li>发明之初被称为cBPF（classic BPF），是一款网络过滤神器，衍生工具有tcpdump等。<br></li><li>发展演进成一套通用执行引擎eBPF（extended Berkeley Packet Filter），不再仅仅是网络分析，还可以基于eBPF开发性能分析、系统追踪、网络优化等多种类型的工具和平台。<br></li></ul><h3 id="1-1-为什么需要BPF"><a href="#1-1-为什么需要BPF" class="headerlink" title="1.1 为什么需要BPF"></a>1.1 为什么需要BPF</h3><p>过去的程序为了分析只在内核空间运行的数据，必须将数据从内核空间复制到用户空间的内存中去，并进行上下文切换。而这与直接在内核空间分析数据相比，产生了巨大的性能开销。随着近年来网络速度和流量的快速增长（音频、视频流媒体数据），在用户空间监控分析那么多的流量数据已经不可行了，一种在内核空间执行高效安全的程序的机制BPF就应运而生了。<br><br>1992年，《The BSD Packet Filter: A New Architecture for User-level Packet Capture》论文中第一次提出BPF技术，文中描述了如何在Unix内核实现网络数据包过滤，比当时的数据包过滤技术快20倍。<br></p><h3 id="1-2-BPF内核编程的好处"><a href="#1-2-BPF内核编程的好处" class="headerlink" title="1.2 BPF内核编程的好处"></a>1.2 BPF内核编程的好处</h3><p>传统的Linux内核开发需要实现强安全、高性能和持续交付。<br><br>现有的方案存在以下问题：</p><ul><li>1）直接修改内核代码——&gt;内核版本更新满，每次功能更新都需要重新编译打包内核代码；<br></li><li>2）开发新的可即时加载的内核模块，用户可以在运行时加载到Linux内核中进而扩展内核功能——&gt;内核模块需要跟着内核版本的更新进行调整，此外还存在让内核crash的风险。<br></li></ul><p>BPF通过BPF验证器、JIT编译器和用户空间可编程三个特性实现了内核开发的需求：</p><ul><li>1）强安全：BPF验证器（verifier）会检查将要运行到内核空间的程序的每一行是否安全可靠，如果检查不通过，它将拒绝这个程序被加载到内核中去，从而保证内核本身不会崩溃<em>（这是不同于开发内核模块的）</em>。<br></li><li>2）高性能：Just-In-Time（指令即时翻译）编译器保证了程序本地运行的高性能。<br></li><li>3）持续交付：可以在不影响系统运行的情况下，实时在线地替换这些运行在Linux内核中的eBPF程序。<br></li></ul><h3 id="1-3-eBPF架构"><a href="#1-3-eBPF架构" class="headerlink" title="1.3 eBPF架构"></a>1.3 eBPF架构</h3><p>介绍：用户把eBPF程序编译为eBPF指令，然后通过bpf()系统调用将eBPF指令加载到内核的特定挂载点，由特定的事件来触发eBPF指令的执行。在挂载eBPF指令时内核会进行充分验证，避免eBPF代码影响内核的安全和稳定性。另外内核也会进行JIT编译，把eBPF指令翻译为本地指令，减少性能开销。<br></p><p><img src="/assets/blog/eBPF-1.jpg" alt="Alt text"><br></p><center>图来自https://www.ebpf.top/post/ebpf_intro/</center><p>eBPF用户空间程序和内核中的BPF字节码交互流程如下：</p><ul><li>1）用户自定义程序，使用LLVM或GCC工具将编写的BPF代码程序编译成BPF字节码。<br></li><li>2）字节码被装载到内核VM中，基于类RISC指令的VM运行在内核空间。<br></li><li>3）其中，字节码通过BPF Verifier确保内核安全。<br></li><li>4）验证后的字节码通过BPF JIT机制转成内核可执行的本地指令运行。<br></li></ul><p>上述流程中涉及到的程序的装载过程具体是：通过<strong>bpf()系统调用</strong>将eBPF程序装载到内核中，其中包含多种bpf命令，用于用户空间与内核VM交互。<br>注意：BPF程序不是以机器指令加载到内核的，而是以字节码形式加载到内核中的。</p><p><img src="/assets/blog/eBPF-2.jpg" alt="Alt text"><br></p><p>上述流程中涉及到的程序验证具体是：保证程序的安全执行，不破坏内核。主要验证程序的权限、程序不能对内核有损害、程序能够结束（循坏有限）等。<br><br>eBPF是事件驱动的，当内核或应用程序通过某个挂钩点时运行。预定义的钩子包括系统调用、函数入口&#x2F;出口、内核跟踪点、网络事件和其他钩子。<br></p><p><img src="/assets/blog/eBPF-3.jpg" alt="Alt text"><br></p><center>图来自(eBPF概念及在可观测性、网络、安全和优化领域的应用)</center><p>内核中运行的BPF字节码程序可以使用两种方式将测量数据回传至用户空间：<br></p><ul><li>1）eBPF maps，被设计成 key&#x2F;value 的形式，能够在用户态程序与内核态eBPF程序之间进行双向通信。<br></li><li>2）perf-event&#x2F;ringbuffer 用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析。<br></li></ul><h2 id="二、eBPF编程"><a href="#二、eBPF编程" class="headerlink" title="二、eBPF编程"></a>二、eBPF编程</h2><p>BPF开发工具总结如下图，这里笔者主要使用bpftrace和libbpf-bootstrap进行内核跟踪的开发实践。<br><br><img src="/assets/blog/eBPF-4.jpg" alt="Alt text"><br></p><h3 id="2-1-bpftrace实践"><a href="#2-1-bpftrace实践" class="headerlink" title="2.1 bpftrace实践"></a>2.1 bpftrace实践</h3><p>bpftrace在eBPF和BCC之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的跟踪功能。</p><blockquote><p>安装bpftrace参考：<a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md">https://github.com/iovisor/bpftrace/blob/master/INSTALL.md</a> 。<br>若未正确安装可能会出现“lockdown is enabled and set to ‘confidentiality’”报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l &#x27;*execve*&#x27;</span><br><span class="line">sudo bpftrace -l ｜grep execve</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这些函数可以分为 tracepoint（内核静态探针），kprobe（内核态动态函数探针）和 kfunc （基于BPF的内核态动态函数探针）三类。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kfunc，kprobe属于不稳定接口，而tracepoint则是稳定接口。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因而，优先选择更稳定的跟踪点，以保证 eBPF 程序的可移植性（即在不同版本的内核中都可以正常执行）。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-5.jpg" alt="Alt text"><br></p><h4 id="2-1-1-tracepoint跟踪"><a href="#2-1-1-tracepoint跟踪" class="headerlink" title="2.1.1 tracepoint跟踪"></a>2.1.1 tracepoint跟踪</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪系统调用execve查看入口参数</span></span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_exit_execve &#123; printf(&quot;%-6d %-8s ret=%d \n&quot;,pid,comm,args-&gt;ret); &#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123; printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bpftrace -e ：表示直接从后面的字符串参数中读入bpftrace程序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tracepoint:syscalls:sys_enter_execve表示跟踪的函数，如果多个函数可以用逗号分隔，后面&#123;&#125;中表示跟踪点的处理函数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理函数如：<span class="built_in">printf</span>()表示向终端中打印字符串，其用法就是C语言中的<span class="built_in">printf</span>()函数。其中pid和<span class="built_in">comm</span>是bpftrace内置的变量，分别表示进程PID和进程名称。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-6.jpg" alt="Alt text"><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还可以写成脚本的形式：vim jiaoben.bt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bpftrace</span></span><br><span class="line">tracepoint:syscalls:sys_enter_execve </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 sudo ./jiaoben.bt 即可达到上述命令行效果</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-kprobe监控"><a href="#2-1-2-kprobe监控" class="headerlink" title="2.1.2 kprobe监控"></a>2.1.2 kprobe监控</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核动态探针kprobe监控内核函数vfs_open的跟踪点和入口参数</span></span><br><span class="line">sudo bpftrace -lv kfunc:vfs_open</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核函数的调用栈</span></span><br><span class="line">sudo bpftrace -e &#x27;kprobe:vfs_open &#123; @[kstack(perf)] = count(); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-7.jpg" alt="Alt text"><br></p><h4 id="2-1-3-用户态函数探针检测"><a href="#2-1-3-用户态函数探针检测" class="headerlink" title="2.1.3 用户态函数探针检测"></a>2.1.3 用户态函数探针检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用用户态函数探针 uprobe和uprobe检测用户态的程序test</span></span><br><span class="line"><span class="comment">// 编写test.c文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成test应用程序：gcc -g test.c -o test</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用bpftrace跟踪<span class="built_in">test</span>程序的main函数，输出参数个数、第1个参数和返回值：</span></span><br><span class="line">sudo bpftrace -e &#x27;uprobe:/home/jian/Desktop/bpf/third/test:main &#123;printf(&quot;count:%d  &quot;,arg0);join(arg1)&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/home/jian/Desktop/bpf/third/test:main &#123; printf(&quot;test main return %d\n&quot;, retval); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用用户态函数探针 uretprobe检测开源应用程序bash</span></span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/usr/bin/bash:readline &#123; printf(&quot;User %d executed \&quot;%s\&quot; command\n&quot;, uid, str(retval)); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-8.jpg" alt="Alt text"><br></p><h4 id="2-1-4-事件检测"><a href="#2-1-4-事件检测" class="headerlink" title="2.1.4 事件检测"></a>2.1.4 事件检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针Software检测软件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;s:*&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;software:page-faults:100 &#123; @[comm] = count(); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针hardware检测硬件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;h:*&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟机环境不支持</span></span><br></pre></td></tr></table></figure><h3 id="2-2-libbpf实践"><a href="#2-2-libbpf实践" class="headerlink" title="2.2 libbpf实践"></a>2.2 libbpf实践</h3><p>BCC依赖于LLVM和内核头文件才可以动态编译和加载eBPF程序，然而，很多环境中通常没有甚至不允许安装这些开发工具。其中一种解决方案就是使用libbpf来开发一个eBPF程序。<br></p><blockquote><p>首先需要知道，一个以开发BPF程序为目的的工程通常由两类源文件组成：</p><ul><li>一类是运行于内核态的BPF程序的源代码文件.</li><li>另外一类是用于向内核加载BPF程序、从内核卸载BPF程序、与内核态进行数据交互、展现用户态程序逻辑的用户态程序的源代码文件。</li></ul></blockquote><h4 id="2-2-1-基于libbpf-bootstrap项目的实现"><a href="#2-2-1-基于libbpf-bootstrap项目的实现" class="headerlink" title="2.2.1 基于libbpf-bootstrap项目的实现"></a>2.2.1 基于libbpf-bootstrap项目的实现</h4><p>内核BPF开发者Andrii Nakryiko在github上开源了一个直接基于libbpf开发BPF程序与加载器的引导项目libbpf-bootstrap，这个项目中包含使用c和rust开发BPF程序和用户态程序的例子。下图是基于libbpf-bootstrap实现的hello world程序实例的示意图。</p><p><img src="/assets/blog/eBPF-9.jpg" alt="Alt text"><br></p><center>图来自参考链接“使用C语言...eBPF程序”</center><ul><li>图中的libbpf其实是指linux内核代码库中的tools&#x2F;lib&#x2F;bpf，是内核提供给外部开发者的C库，用于创建BPF用户态的程序。<br></li><li>图中的bpftool对应的是linux内核代码库中的tools&#x2F;bpf&#x2F;bpftool，是一个bpf辅助工具，在libbpf-bootstrap中用于生成xx.skel.h。（在eBPF程序中，由于内核已经支持了BPF，因此不再需要引入众多的内核头文件来获取内核数据结构的定义。取而代之的是一个通过bpftool生成的vmlinux.h头文件——也就是xx.skel.h，其中包含了内核数据结构的定义。<br></li><li>helloworld.bpf.c是bpf程序对应的源码，通过clang -target&#x3D;bpf编译成BPF字节码ELF文件helloworld.bpf.o。<br></li><li>libbpf-bootstrap并没有使用用户态加载程序直接去加载helloworld.bpf.o，而是通过bpftool gen命令基于helloworld.bpf.o生成helloworld.skel.h文件，在生成的helloworld.skel.h文件中包含了BPF程序的字节码以及加载、卸载对应BPF程序的函数，我们在用户态程序直接调用即可。<br></li><li>helloworld.c是BPF用户态程序，它只需要include helloworld.skel.h并按套路加载、挂接BPF程序到内核层对应的埋点即可。由于BPF程序内嵌到用户态程序中，我们在分发BPF程序时只需分发用户态程序即可！<br></li></ul><p>结合上述流程分析，基于libbpf-bootstrap的eBPF程序的开发流程如下：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装依赖</span></span><br><span class="line">sudo apt-get install make clang llvm libelf-dev pkg-config gcc binutils-dev libcap-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.下载libbpf-bootstrap</span></span><br><span class="line">git clone https://github.com/libbpf/libbpf-bootstrap.git</span><br><span class="line">cd libbpf-bootstrap/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.初始化和更新libbpf-bootstrap的依赖</span></span><br><span class="line">cat .gitmodules</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.基于libbpf-bootstrap框架的BPF程序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入libbpf-bootstrap/examples/c目录下，在该目录下创建两个C源文件helloworld.bpf.c和helloworld.c(参考了minimal.bpf.c和minimal.c)，显然前者是运行在内核态的BPF程序的源码，而后者则是用于加载BPF到内核的用户态程序。</span></span><br><span class="line">cd examples/c</span><br><span class="line">sudo make minimal</span><br><span class="line">sudo ./minimal</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/trace_pipe</span><br></pre></td></tr></table></figure><h4 id="2-2-2-基于libbpf的独立实现"><a href="#2-2-2-基于libbpf的独立实现" class="headerlink" title="2.2.2 基于libbpf的独立实现"></a>2.2.2 基于libbpf的独立实现</h4><p>使用libbpf开发eBPF程序也是需要内核态的eBPF程序和用户态的加载、挂载、映射读取以及输出程序的，步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装libbpf库和bpftool工具。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.在任意路径下建立一个helloworld目录，将前面的helloworld.bpf.c和helloworld.c拷贝到该helloworld目录下。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.编写Makefile。整个Makefile的构建过程与libbpf-bootstrap中的Makefile异曲同工，同样是先编译bpf字节码，然后生成内核头文件helloworld.skel.h。最后编译依赖helloworld.skel.h的helloworld程序。</span></span><br></pre></td></tr></table></figure><p>本节从libbpf-bootstrap下的minimal例子入手，学习libbpf的代码风格及eBPF编程中的一些规则和定义。<br>minimal app示例包括内核程序minimal.bpf.c和用户程序minimal.c。</p><h5 id="2-2-2-1-minimal-bpf-c"><a href="#2-2-2-1-minimal-bpf-c" class="headerlink" title="2.2.2.1 minimal.bpf.c"></a>2.2.2.1 minimal.bpf.c</h5><p>内核代码编程中的一些规则：<br></p><blockquote><ul><li>BPF代码可以读取和更新全局变量，就像其他用户空间的C代码对待全局变量那样。使用BPF全局变量维护程序的状态很方便，而且性能表现也不错。</li><li>另外，BPF全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。在用额外的设置项配置BPF程序的时候常常会用到它。它也经常用于在内核中的BPF代码和用户侧的控制代码之间传递数据。</li><li>在同一个BPF C程序文件中，可能有多个BPF程序。他们可以是不同类型的，有着不同的 SEC() 宏。例如，你可以用不同的BPF程序追踪不同的系统调用或其他事件（如网络包的处理）。也可以使用相同的SEC()宏来定义多个BPF程序，libbpf会自动处理他们。</li><li>在同一个BPF C代码文件中的所有的BPF程序共享所有的全局状态，例如下面例子中的my_pid变量，如果使用了BPF map，它也是共享的。</li><li>bpf_printk()帮助函数和trace_pipe文件一般不在生产环境中使用，通常是用来辅助BPF程序的debug的，目前还没有BPF的调试工具，所以这种输出调试是目前最方便的调试方法了。</li><li>通过查看&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下的内容可以查看系统中所有可用的跟踪点。查看&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;bpf目录下定义的事件可以查看BPF可用的所有跟踪点。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2020 Facebook */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span>    <span class="comment">//导入了一些基础必要的BPF相关的类型和常量，以便使用内核侧的BPF API，例如BPF helper function flags。头文件&lt;linux/bpf.h&gt;是之后导入bpf_helpers.h这个头文件所必须的前提。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span>    <span class="comment">//bpf_helpers.h 是由libbpf提供的，包含了大多数常用的宏、常量和BPF helper的定义，几乎会在每个BPF应用中用到。</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;    </span><br><span class="line"><span class="comment">// LICENSE变量定义了BPF代码的 license。在内核开发中，明确license是必须的。一些 BPF功能对于不兼容GPL的代码是不可用的。</span></span><br><span class="line"><span class="comment">// 注意特殊的 SEC(&quot;license&quot;) 注解。</span></span><br><span class="line"><span class="comment">// 定义在bpf_helpers.h中的SEC()把变量和函数放到了特殊的段中。SEC(&quot;license&quot;) 和一些其他的段名，是libbpf规定的，只要遵循就好了。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_pid = <span class="number">0</span>;    <span class="comment">// 定义了一个全局变量my_pid。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该段BPF程序会被加载到内核中。</span></span><br><span class="line"><span class="comment">它是由一个普通的C函数定义的，使用SEC()宏放在一个特殊的段中。</span></span><br><span class="line"><span class="comment">段名定义了libbpf程序创建的是什么类型的BPF程序，以及它是附着到内核上哪个地方的。</span></span><br><span class="line"><span class="comment">在这个例子中，我们是定义了一个tracepoint BPF程序，每次用户空间的应用调用了系统调用write()的时候，就会触发它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SEC(<span class="string">&quot;tp/syscalls/sys_enter_write&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_tp</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取了PID（内核术语中的 &quot;TGID&quot; ），它存储在 bpf_get_current_pid_tgid()返回值高32位。</span></span><br><span class="line"><span class="type">int</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; </span><br><span class="line">    <span class="comment">// 查看触发了write()系统调用的进程是否是我们的minimal进程。</span></span><br><span class="line">    <span class="comment">// 全局变量 my_pid 是通过之后的用户空间的代码进行初始化的，它会被初始化成真实的PID值。</span></span><br><span class="line"><span class="keyword">if</span> (pid != my_pid)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bpf_printk就是BPF中的printf(&quot;Hello, world!\n&quot;)。它输出格式化的字符串到/sys/kernel/debug/tracing/trace_pipe，可以sudo从控制台中去查看它的内容。</span></span><br><span class="line">bpf_printk(<span class="string">&quot;BPF triggered from PID %d.\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bpftool会根据bpf字节码文件（xxx.bpf.o）生成对应的skeleton文件——xxx.skel.h。这个文件中包含了关键的函数和结构体。</p><h5 id="2-2-2-2-minimal-c"><a href="#2-2-2-2-minimal-c" class="headerlink" title="2.2.2.2 minimal.c"></a>2.2.2.2 minimal.c</h5><p>用户空间代码minimal.c如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span> <span class="comment">// rlimit使用——对进程设置资源限制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/libbpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minimal.skel.h&quot;</span> <span class="comment">// 由bpftool自动生成的文件，它高度抽象了minimal.bpf.c的结构。</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">libbpf_print_fn</span><span class="params">(<span class="keyword">enum</span> libbpf_print_level level, <span class="type">const</span> <span class="type">char</span> *format, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">minimal_bpf</span> *<span class="title">skel</span>;</span> <span class="comment">// bpftool生成到skel文件中，格式都是xxx_bpf。</span></span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bpf程序资源限制</span></span><br><span class="line">        libbpf_set_strict_mode(LIBBPF_STRICT_ALL);</span><br><span class="line">        <span class="comment">// libbpf_set_print() 提供了一个自定义的回调给所有的 libbpf 日志输出。</span></span><br><span class="line">        <span class="comment">// 默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。</span></span><br><span class="line">        libbpf_set_print(libbpf_print_fn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步，打开bpf文件，返回指向xxx_bpf的指针（在.skel中定义）</span></span><br><span class="line">        skel = minimal_bpf__open();</span><br><span class="line">        <span class="keyword">if</span> (!skel) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ensure BPF program only handles write() syscalls from our process */</span></span><br><span class="line">        <span class="comment">// Skeleton 也可以包含可选的 bss、data、rodata 段，从而可以直接从用户空间访问 BPF 全局变量而不必使用额外的系统调用。</span></span><br><span class="line">skel-&gt;bss-&gt;my_pid = getpid();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 第二步，加载及校验bpf程序</span></span><br><span class="line">        err = minimal_bpf__load(skel);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步，附加到指定的hook点</span></span><br><span class="line">        err = minimal_bpf__attach(skel);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to attach BPF skeleton\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` &quot;</span></span><br><span class="line">               <span class="string">&quot;to see output of the BPF programs.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该无穷循环确保了BPF程序handle_tp能够一直附着在内核中，直到用户关掉进程，如按下 Ctrl-C。</span></span><br><span class="line">        <span class="comment">// 同时，它还会每秒调用 fprintf(stderr, ...)，从而触发一次 write() 系统调用。通过这种方法，可以通过handle_tp监控内核的内部情况和状态随时间的变化。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">/* trigger our BPF program */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">cleanup:</span><br><span class="line">        minimal_bpf__destroy(skel);</span><br><span class="line">        <span class="keyword">return</span> -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-3-MakeFile"><a href="#2-2-2-3-MakeFile" class="headerlink" title="2.2.2.3 MakeFile"></a>2.2.2.3 MakeFile</h5><p>libbpf-bootstrap 中的 Makefile 和 CMakeList.txt 规定了源文件名的规则：</p><ul><li>1）生成bpf字节码的 bpf 文件以 .bpf.c 结尾。<br></li><li>2）加载bpf字节码的c文件以.c 结尾。<br></li><li>3）上述两个类型文件名的前缀必须相同。</li></ul><h2 id="三、eBPF-map"><a href="#三、eBPF-map" class="headerlink" title="三、eBPF map"></a>三、eBPF map</h2><h3 id="3-1-map概念"><a href="#3-1-map概念" class="headerlink" title="3.1 map概念"></a>3.1 map概念</h3><ul><li>BPF Map以“键&#x2F;值”方式存储在内核中，可以被任何BPF程序访问。在内核空间的程序创建BPF Map并返回对应的文件描述符，在用户空间运行的程序就可以通过文件描述符来访问并操作BPF Map。</li><li>BPF映射提供了内核和用户空间双向数据共享，允许用户从内核和用户空间读取和写入数据。BPF映射的数据结构类型可以从简单数组、哈希映射到自定义类型映射。</li><li>map创建原理：ebpf程序需要由用户态进程（程序）load进内核，由于bpf syscall的存在，ebpf map创建可以大致分两种方式：1）用户态进程通过bpf syscall来创建和管理eBPF map；2）内核态在load ebpf程序的时候通过解析ELF文件的map section来创建ebpf map。</li></ul><h3 id="3-2-map相关函数"><a href="#3-2-map相关函数" class="headerlink" title="3.2 map相关函数"></a>3.2 map相关函数</h3><p>内核提供了一些约定和帮助函数，用于生成和使用BPF映射。由于内核程序需要从bpf&#x2F;bpf_helper.h文件加载函数，而用户空间程序则需要从lib&#x2F;bpf&#x2F;bpf.h文件加载，所以内核程序访问的函数签名与用户空间访问的函数签名并不相同，具体表现在：</p><ul><li>内核程序可以直接访问map，而用户空间程序需要使用文件描述符fd来引用map。</li><li>内核程序和用户空间程序调用函数的行为也不同。<br>本节介绍了eBPF编程中常使用的map相关的helper函数，并分别说明了其在用户态和内核态的用法。<br><br>查看完整的各种bpf helper函数相关用法可参见博客<a href="https://blog.gmem.cc/ebpf">https://blog.gmem.cc/ebpf</a> 和 <a href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/">https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/</a> 。</li></ul><h4 id="3-2-1-更新BPF-map元素——bpf-map-update-elem"><a href="#3-2-1-更新BPF-map元素——bpf-map-update-elem" class="headerlink" title="3.2.1 更新BPF map元素——bpf_map_update_elem()"></a>3.2.1 更新BPF map元素——bpf_map_update_elem()</h4><ul><li><strong>内核程序</strong>：long bpf_map_update_elem(struct bpf_map *map, const void *key, const void *value, u64 flags)更新指定key的值， flags参数用于控制更新行为。</li></ul><blockquote><p>flags参数有三个值：BPF_ANY表示0（如果元素存在，内核将更新元素；如果不存在，则在map中创建该元素）；BPF_NOEXIST表示1（仅当元素不存在时，创建元素）；BPF_EXIST表示2（仅当元素存在时，内核更新元素）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_map_update_elem(&amp;event_map, &amp;pid, &amp;event, BPF_ANY);</span><br></pre></td></tr></table></figure><ul><li><strong>用户态程序</strong>：int bpf_map_update_elem(int fd, const void *key, const void *value,__u64 flags)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = bpf_map__update_elem(fd, &amp;key, &amp;value, BPF_ANY);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-2-读取-x2F-查找BPF-map元素——bpf-map-lookup-elem"><a href="#3-2-2-读取-x2F-查找BPF-map元素——bpf-map-lookup-elem" class="headerlink" title="3.2.2 读取&#x2F;查找BPF map元素——bpf_map_lookup_elem()"></a>3.2.2 读取&#x2F;查找BPF map元素——bpf_map_lookup_elem()</h4><ul><li><strong>内核程序</strong>：void *bpf_map_lookup_elem(struct bpf_map *map, const void *key)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = bpf_map_lookup_elem(&amp;execve_counter, &amp;key);</span><br></pre></td></tr></table></figure></li><li><strong>用户态程序</strong>：int bpf_map_lookup_elem(int fd, const void *key, void *value)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立 map</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span> =</span> bpf_object__find_map_by_name(obj, <span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map__lookup_elem(<span class="built_in">map</span>, &amp;key, <span class="keyword">sizeof</span>(key), &amp;val, <span class="keyword">sizeof</span>(val), <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;val:%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、开发实践"><a href="#四、开发实践" class="headerlink" title="四、开发实践"></a>四、开发实践</h2><h3 id="4-1-使用libbpf和BCC的区别"><a href="#4-1-使用libbpf和BCC的区别" class="headerlink" title="4.1 使用libbpf和BCC的区别"></a>4.1 使用libbpf和BCC的区别</h3><ul><li>使用libbpf&#x2F;BPF CO-RE，不需要包含内核头文件（即，所有这些 #include &lt;linux&#x2F;whatever.h&gt;）， 而是包含一个 vmlinux.h和几个libbpf帮助头文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span>               <span class="comment">/* all kernel types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span>       <span class="comment">/* most used helpers: SEC, __always_inline, etc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span>     <span class="comment">/* for BPF CO-RE helpers */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span>       <span class="comment">/* for getting kprobe arguments */</span></span></span><br></pre></td></tr></table></figure></li><li>BCC和libbpf以声明方式定义map的方式有所不同，libbpf以struct结构体的形式定义map数据，并需要明确指定大小。</li><li>常见libbpf命名规范：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tp/&lt;category&gt;/&lt;name&gt; 用于 tracepoints；</span><br><span class="line">kprobe/&lt;func_name&gt; 用于 kprobe 和 kretprobe/&lt;func_name&gt; 用于 kretprobe；</span><br><span class="line">raw_tp/&lt;name&gt; 用于原始 tracepoint；</span><br><span class="line">cgroup_skb/ingress 、cgroup_skb/egress 和整个系列的 cgroup/&lt;subtype&gt; 程序。</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-BPF-ring-buffer-和-BPF-perf-buffer"><a href="#4-2-BPF-ring-buffer-和-BPF-perf-buffer" class="headerlink" title="4.2 BPF ring buffer 和 BPF perf buffer"></a>4.2 BPF ring buffer 和 BPF perf buffer</h3><ul><li>Perf Buffer是每个CPU缓冲区的集合，允许内核和用户空间之间高效地交换数据，但由于perfbuf是基于CPU的设计，存在内存使用效率低和事件重新排序的缺点。</li><li>从Linux 5.8开始，BPF提供了ring buffer，是一个多生产者单消费者队列，可以同时在多个CPU之间安全地共享，解决了perfbuf内存开销和数据排序的问题。<br><br>以下分析针对<a href="https://www.ebpf.top/post/bpf_ring_buffer/">博客文章——BPF 环形缓冲区</a>中开源的例子：<br></li></ul><h4 id="4-2-1-perf-buffer"><a href="#4-2-1-perf-buffer" class="headerlink" title="4.2.1 perf buffer"></a>4.2.1 perf buffer</h4><ul><li>1、定义事件的数据结构，此数据结构用于BPF程序发送的数据，同时用于程序的用户空间部分使用。</li><li>2、定义BPF perfbuf为BPF_MAP_TYPE_PERF_EVENT_ARRAY映射。</li><li>3、BPF程序：附加到跟踪点上，为样本获取一个临时存储，并用跟踪点上下文中的数据填充它。完成后，它将通过调用bpf_perf_event_output()发送样本到BPF perfbuf。该API会在当前CPU的perf缓冲区中为数据结构event预留空间，将数据复制到该预留空间，完成后将向用户空间发出新数据可用的信号。此时，epoll子系统将唤醒用户空间处理程序，并将指针传递到该数据副本进行处理。</li><li>4、用户空间部分：使用libbpf用户空间的perf_buffer__new() API创建一个perf缓冲区使用实例，对于提交样本libbpf将调用handle_event()回调，该回调仅调用printf()打印数据。</li></ul><h4 id="4-2-2-ring-buffer"><a href="#4-2-2-ring-buffer" class="headerlink" title="4.2.2 ring buffer"></a>4.2.2 ring buffer</h4><ul><li>1、BPF程序的区别：bpf_perf_event_output()类似于bpf_ringbuf_output()，是bpf_ringbuf_output()的替代，唯一的区别是ringbuf API不需要引用BPF程序上下文。此外，BPF ringbuf 映射定义略有不同。</li><li>2、用户空间代码：更简单的ring_buffer__new() API，ring_buffer__poll() 替换 perf_buffer__poll().</li><li>3、首选reserve&#x2F;commit API，相比bpf_ringbuf_output()，消除了额外的内存复制和临时存储空间的需求。</li></ul><h3 id="4-3-开发过程中遇到的一些问题"><a href="#4-3-开发过程中遇到的一些问题" class="headerlink" title="4.3 开发过程中遇到的一些问题"></a>4.3 开发过程中遇到的一些问题</h3><h4 id="4-3-1-vmlinux头文件中类型重定义错误"><a href="#4-3-1-vmlinux头文件中类型重定义错误" class="headerlink" title="4.3.1 vmlinux头文件中类型重定义错误"></a>4.3.1 vmlinux头文件中类型重定义错误</h4><ul><li>解决方案：vmlinux.h和bpf.h冲突，删除bpf.h include。</li></ul><h4 id="4-3-2-如何在BPF程序中按照PID过滤"><a href="#4-3-2-如何在BPF程序中按照PID过滤" class="headerlink" title="4.3.2 如何在BPF程序中按照PID过滤"></a>4.3.2 如何在BPF程序中按照PID过滤</h4><ul><li>问题分析：PID是进程标识符，按照PID过滤则需要了解进程在内核空间的结构。</li><li>Linux进程：<br>在Linux系统中进程在内核空间一般用任务&#x2F;Task来表示，内核中对应的结构为task_struct。<br>用户创建的线程在Linux内核中也会对等创建一个task_struct结构，属于同一个进程的多个线程对应的task_struct结构在底层实现了进程级别资源的共享，比如内存、信号量、文件等。<br></li><li>进程pid的过滤：bpf_get_current_pid_tgid() &gt;&gt; 32，高32位置为tgid，低32位为 pid(tid)。</li></ul><h4 id="4-3-3-如何获得挂载点上下文信息的格式"><a href="#4-3-3-如何获得挂载点上下文信息的格式" class="headerlink" title="4.3.3 如何获得挂载点上下文信息的格式"></a>4.3.3 如何获得挂载点上下文信息的格式</h4><ul><li>解决方案： cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;sched&#x2F;sched_process_fork&#x2F;format</li></ul><h3 id="4-4-如何查询内核中的跟踪点"><a href="#4-4-如何查询内核中的跟踪点" class="headerlink" title="4.4 如何查询内核中的跟踪点"></a>4.4 如何查询内核中的跟踪点</h3><p>事件源：Kprobe、Tracepoint、Uprobe以及USDT。</p><p><img src="/assets/blog/eBPF3-1.jpg" alt="Alt text"><br></p><center>图截取自报告《eBPF概念及在可观测性、网络、安全和优化领域的应用》</center><h4 id="4-4-1-利用调试信息查询跟踪点"><a href="#4-4-1-利用调试信息查询跟踪点" class="headerlink" title="4.4.1 利用调试信息查询跟踪点"></a>4.4.1 利用调试信息查询跟踪点</h4><ul><li>为了方便调试，内核把所有函数以及非栈变量的地址都抽取到了 <strong>&#x2F;proc&#x2F;kallsyms</strong>中，调试器可以根据地址找出对应的函数和变量名称。然而，不是所有的内核函数都是可跟踪的，只有显式导出的内核函数才可以被eBPF进行动态跟踪。因而，通常我们并不直接从内核符号表查询可跟踪点。</li><li>为了方便内核开发者获取所需的跟踪点信息，内核<strong>调试文件系统</strong>还向用户空间提供了内核调试所需的基本信息，如内核符号列表、跟踪点、函数跟踪（ftrace）状态以及参数格式等。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核调试文件系统的具体信息</span></span><br><span class="line">sudo ls /sys/kernel/debug</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询execve系统调用的参数格式</span></span><br><span class="line">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format</span><br></pre></td></tr></table></figure></li><li>有了调试文件系统，可以从&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing中找到所有内核预定义的跟踪点，进而可以在需要时把eBPF程序挂载到对应的跟踪点。</li></ul><h4 id="4-4-2-利用bpftrace查询跟踪点"><a href="#4-4-2-利用bpftrace查询跟踪点" class="headerlink" title="4.4.2 利用bpftrace查询跟踪点"></a>4.4.2 利用bpftrace查询跟踪点</h4><ul><li>bpftrace会把你开发的脚本借助BCC编译加载到内核中执行，再通过BPF映射获取执行的结果。因此，在编写简单的eBPF程序，特别是编写的eBPF程序用于临时的调试和排错时，可以考虑直接使用bpftrace，而不需要用C或Python去开发一个复杂的程序。</li><li>可以执行 <strong>bpftrace -l</strong> 来查询内核插桩和跟踪点：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有的系统调用跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;tracepoint:syscalls:*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有名字包含&quot;execve&quot;的跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure></li><li>对于跟踪点来说，还可以加上-v参数查询函数的入口参数或返回值。而由于内核函数属于不稳定的API，在bpftrace中只能通过 arg0、arg1 这样的参数来访问，具体的参数格式还需要参考内核源代码。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询execve入口参数格式</span></span><br><span class="line">sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">$ tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询execve返回值格式</span></span><br><span class="line">sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">$ tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-3-kprobe参数查看"><a href="#4-4-3-kprobe参数查看" class="headerlink" title="4.4.3 kprobe参数查看"></a>4.4.3 kprobe参数查看</h4><ul><li>与tracepoint:不同，无法用”bpftrace -lv”查看”kprobe”的参数，但可以查看相应的”kfunc:*”间接知道参数；或者可以借助stap快速查看参数；或直接查看内核源码。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -lv &#x27;kfunc:bpf_lsm_task_alloc&#x27;</span><br><span class="line">stap -L ‘kernel.function(“do_sys_openat2”)’</span><br></pre></td></tr></table></figure></li><li>列出kprobe所有可用函数：cat &#x2F;proc&#x2F;kallsyms</li></ul><h4 id="4-4-4-tracepoint类型程序"><a href="#4-4-4-tracepoint类型程序" class="headerlink" title="4.4.4 tracepoint类型程序"></a>4.4.4 tracepoint类型程序</h4><ul><li>tracepoint 事件对应的 SEC 格式为:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_openat&quot;</span>)     <span class="comment">// 即SEC(&quot;tracepoint/&lt;category&gt;/&lt;name&gt;&quot;)</span></span><br><span class="line">SEC(<span class="string">&quot;tp/syscalls/sys_enter_openat&quot;</span>)      <span class="comment">// 或者SEC(&quot;tp/&lt;category&gt;/&lt;name&gt;&quot;)</span></span><br></pre></td></tr></table></figure></li><li>如何确定ebpf中事件处理函数的参数类型：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strace chmod 600 a.txt   # 先确定 chmod 所使用的系统调用</span><br><span class="line">cat /sys/kernel/debug/tracing/available_events |grep fchmodat  # 找到针对这个系统调用可以使用的 tracepoint 事件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确定函数的参数类型，这个需要到 vmlinux.h 文件中进行查找。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般 sys_enter_xx 对应 trace_event_raw_sys_enter</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sys_exit_xx 对应 trace_event_raw_sys_exit</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他的一般对应 trace_event_raw_&lt;name&gt;</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没找到的话，可以参考 trace_event_raw_sys_enter 的例子找它相近的 struct。</span> </span><br></pre></td></tr></table></figure></li><li>如何获取到对应的系统调用涉及的参数的内容：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format</span><br><span class="line"><span class="comment"># print fmt 中引用的字段都是我们可以在 ebpf 程序中获取的信息。 </span></span><br><span class="line"><span class="comment"># 这些字段的值可以通过 trace_event_raw_sys_enter 的 args 数组获取，即通过 args[0] 获取 dfd , args[1] 获取 filename 以此类推。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-5-跟踪点的选取"><a href="#4-4-5-跟踪点的选取" class="headerlink" title="4.4.5 跟踪点的选取"></a>4.4.5 跟踪点的选取</h4><ul><li>内核插桩（kprobe）属于不稳定接口，而跟踪点（tracepoint）则是稳定接口。因而，在内核插桩和跟踪点两者都可用的情况下，应该选择<strong>更稳定的跟踪点</strong>，以保证eBPF程序的可移植性（即在不同版本的内核中都可以正常执行）。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.ebpf.top/post/ebpf_intro/">博客文章——eBPF技术简介</a></li><li><a href="https://www.bilibili.com/video/BV1PF411V7Lj?share_source=copy_web&vd_source=28532461e369234a7808585e999e9e49">B站视频——陈鹏飞：eBPF概念及在可观测性、网络、安全和优化领域的应用</a></li><li><a href="https://www.youtube.com/watch?v=uBqRv8bDroc&t=2s">Youtube视频——Liz Rice：A Beginner’s Guide to eBPF</a></li><li><a href="https://www.cnblogs.com/lfri/p/15402973.html">博客文章——BPF C编程入门</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123005213">博客文章——使用bpfttrace开发eBEP程序</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123318084">博客文章——使用libbpf开发eBPF程序</a></li><li><a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch/">博客文章——使用C语言从头开发一个Hello World级别的eBPF程序</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210627/">博客文章——使用libbpf-bootstrap构建BPF程序</a></li><li>《Linux内核观测技术BPF》</li><li><a href="https://forsworns.github.io/zh/blogs/20210627/">博客文章——使用 libbpf-bootstrap 构建 BPF 程序</a></li><li><a href="https://blog.csdn.net/qq_40711766/article/details/127288536">博客文章——从零构建libbpf+ebpf CO-RE程序</a></li><li><a href="https://www.bilibili.com/video/BV1Hd4y1o72L?share_source=copy_web&vd_source=28532461e369234a7808585e999e9e49">B站视频——Linux内核调试追踪技术</a></li><li><a href="https://www.edony.ink/deepinsight-of-ebpf-map/">深入了解ebpf map</a></li><li><a href="https://time.geekbang.org/column/article/484207">极客时间——eBPF核心技术与实战</a></li><li><a href="http://blog.nsfocus.net/ebpf/">绿盟科技-eBPF入门文献汇总</a></li><li><a href="https://davidlovezoe.club/wordpress/archives/1044">博客文章——BPF数据传递的桥梁——BPF MAP</a></li><li><a href="https://www.ebpf.top/post/bcc-to-libbpf-guid/">BCC 到 libbpf 的转换指南【译】</a></li><li><a href="https://www.ebpf.top/post/ebpf_prog_pid_filter/">博客文章——如何在 BPF 程序中正确地按照 PID 过滤？</a></li><li><a href="https://www.ebpf.top/post/bpf_ring_buffer/">博客文章——BPF 环形缓冲区</a></li><li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions.html">ebpf&#x2F;libbpf 程序使用 tracepoint 的常见问题</a></li></ul><h2 id="国内eBPF实践团队"><a href="#国内eBPF实践团队" class="headerlink" title="国内eBPF实践团队"></a>国内eBPF实践团队</h2><ul><li>字节跳动STE团队</li><li>阿里云荣旸</li><li>腾讯云TKE团队</li><li>eBay IE Cloud团队</li><li>网易杭研轻舟云原生</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让&lt;strong&gt;操作系统内核可编程化&lt;/strong&gt;，成为云原生时代软件系统的一把利刃。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="eBPF" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>新的学期，新的生活</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2019/09/10/life-1-md/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2019/09/10/life-1-md/</id>
    <published>2019-09-10T09:00:08.000Z</published>
    <updated>2023-02-11T05:07:16.209Z</updated>
    
    <content type="html"><![CDATA[<p>开学也一周多了，这里记录一下最近的感受。<br><br>前几天回所和导师们聊天了，收获颇丰，也深刻地感受到了研究生阶段与本科生阶段求学生涯的重大区别。十分感谢徐老师抽出时间和我聊了那么久，前人的经验与建议往往能给开学之初迷茫的我带来很多帮助。这里记录一下老师的教导，也时刻提醒着自己在新的起点要更加努力。</p><span id="more"></span><p>一要学会主动。不管是技能的获得还是资源的寻找，都要自己主动地去争取。没有人有责任帮助你，你需要学会且习惯去主动地解决自己的问题。且研究生的角色定位更多是导师们的助手，并不是和本科一样完全抱着学习的心态，要找准自己的定位。</br><br>二是发现问题，研究问题，解决问题并总结问题。科研中最大的难点往往是发现问题与解决问题。前者要求你在这个领域这个方向有足够多的研究与深入，才能发现有针对性的有价值的问题。而后者则是对编程等技能的考验。要发现一个有价值的问题需要在这个领域不断深入，广泛地阅读文章，时刻关注该领域的学术动态。</br><br>三是知行合一。所谓知行合一：“知”是指在研究过程中，要注意方法论的积累。科研的方法论需要自己在大量的论文阅读中不断学习总结产生。而“行”则是由于专业的特殊性，在前进过程中避免不了大量的实践与实操，利用自己的知识动手解决问题，而这些都需要自身过硬的技术能力。</br><br>四是对自己高要求。本科时听闻我直博的消息，高老师还曾和我细聊了很久，问及我的想法与计划。当时的我也比较迷茫，只想着提升学历再加上父母也比较支持，就一直没有细细思索过自己直博的真正目的。可不管如何，进入了博士阶段，就要付出自己的努力，好好做科研不断提升技能能力。既然已经决定把自己六年的青春年华留在这里，就要让自己过得值。你想毕业后成为怎样的人，你就必然要付出对应的努力，才能给自己提交一份满意的答卷。（在我的学习道路上遇到了太多好老师，真的十分幸运且心怀感激，在我迷茫之际给了我很多指导与帮助。）</br><br>同时，这几天的课堂生活也让我感触颇多。首先是学会时间管理和作息调整。原来习惯午睡的我在每天满课的状态下根本没法儿维持这个作息了，甚至于有两天午饭时间都十分紧张。还是希望自己能尽快调整好作息，好好管理自己在雁西湖校区的这一年学习时间。其次还是身体问题，原来的时候不注意，这两个月来腰部的疼痛已经严重困扰了我的学习和生活。现在不贴膏药根本无法支撑一天从上午八点到晚上九点四十的坐着的学习生活（感觉自己活成了老年人）。坐了一节课腰部就十分难受，腰肌劳损还是很影响学习和生活的。还是要尽快形成规律的锻炼时间，好好保护自己的身体。</br><br>全篇鸡汤很多但重点也很多，新的学期，新的开始，希望自己能不负韶华，好好努力！！！冲鸭～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学也一周多了，这里记录一下最近的感受。&lt;br&gt;&lt;br&gt;前几天回所和导师们聊天了，收获颇丰，也深刻地感受到了研究生阶段与本科生阶段求学生涯的重大区别。十分感谢徐老师抽出时间和我聊了那么久，前人的经验与建议往往能给开学之初迷茫的我带来很多帮助。这里记录一下老师的教导，也时刻提醒着自己在新的起点要更加努力。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/life/"/>
    
    
    <category term="feeling" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/feeling/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 本地提权漏洞（CVE-2017-16995）</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/</id>
    <published>2018-03-22T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Ubuntu 16.04.1~16.04.4<br>Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）</p><span id="more"></span><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>该漏洞存在于调用eBPF bpf(2)的Linux内核系统中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题， 低权限用户可使用此漏洞获得管理权限。</p><blockquote><p>eBPF - extended Berkeley Packet Filter<br>  简单理解就是用于过滤网络数据包。</p></blockquote><p>EXP下载链接：<a href="https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip">https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip</a></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本来刚开始打算虚拟机复现的，结果安装完发现下的是内核版本为GNU&#x2F;Linux 4.13.0-37-generic x86_64的Ubuntu 16.04，就很难受😣。<br>于是利用i春秋的实验平台复现了一下，结果如下：<br><img src="/assets/blog/1.png" alt="Alt text"></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>Ubuntu 官网暂时没有提供修复方案，可以在评估风险后通过修改内核参数限制普通用户使用 bpf(2) 系统调用来临时修复此漏洞。<br><img src="/assets/blog/2.png" alt="Alt text"></p><blockquote><p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;unprivileged_bpf_disabled</p></blockquote><p>彻底根治方案：更新内核。</p><p>参考链接：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html">eBPF 简史</a><br><a href="https://mp.weixin.qq.com/s/51txDsanj-uSqXdm5GZuEA">i春秋实验</a><br><a href="http://www.yunweipai.com/archives/25298.html">http://www.yunweipai.com/archives/25298.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h4&gt;&lt;p&gt;Ubuntu 16.04.1~16.04.4&lt;br&gt;Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="CVE" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>微信是怎样发送消息的</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/</id>
    <published>2017-12-28T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.009Z</updated>
    
    <content type="html"><![CDATA[<p>从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。</p><p>从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。</p><span id="more"></span><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="/assets/blog/4.png" alt="Alt text">  （图来自课上赵老师）</p><p> 这边首先对数据流量和wifi二者的区别做一个简单介绍：<br>    1、数据流量是通过基站，如果基站覆盖范围大的话，信号接收当然会比wifi好。<br>    2、而wifi是通过wifi接入点（或者简单点理解就是无线路由器），再通过学校交换机，再通过中继器，再通过运营商的路由器。</p><p>手机将文字、图片、语音等数据通过电磁波为载体，在空气中经过上图传播流程后，通过运营商给你接通的讯道传输到对方手机。当手机接收到信号之后再把信号转换，从而实现双方的消息传递。</p><p><em>并没有学过通信原理，这边很多概念也都一知半解，只能浅显地给出自己的一些理解，大佬们轻喷@_@</em></p><h2 id="数据链路层、网络层"><a href="#数据链路层、网络层" class="headerlink" title="数据链路层、网络层"></a>数据链路层、网络层</h2><p>其实在上一段的图中已经提及了，这边也不进一步分析了。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><img src="/assets/blog/5.png" alt="Alt text">    （图来自网络）<br>这边即时通讯关于UDP和TCP的使用区别还是很重要的一个点，也许很多人一听到这个就会下意识地背出“tcp是面向连接的可靠交付，而udp是无连接的不可靠交付”，深入下去其实并不简单。<br>微信既有UDP也有TCP！</p><blockquote><p>UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。微信采用的通信协议以UDP为主，辅以TCP协议。由于微信的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。<br>微信客户端之间的消息传送也采用了UDP模式，因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此微信选择了UDP作为客户之间的主要通信协议。</p></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层这边还是直接看操作吧～</p><p>尝试用wireshark抓包（由于mac微信无法设置代理，也有可能是我还不太熟悉…..这边是对网页版微信的一个抓包）：<br><img src="/assets/blog/6.png" alt="Alt text"><br>先是建立TCP连接：如图前面是TCP的三次握手：<br>    首先客户端向服务器发送标志为SYN的连接请求，数据包标号Seq&#x3D;0；  <br>    收到请求后，服务器向客户端发送了带有SYN和ACK的确认应答，发送序号Seq&#x3D;0，确认序号ACK&#x3D;1；接下来，客户端向服务器发送确认应答，Seq&#x3D;1，ACK&#x3D;1. 连接建立完成。 <br>后面紧跟着的是HTTP数据包，数据最后一行为空行，表明数据已经传送完毕，如下图所示：<br><img src="/assets/blog/7.png" alt="Alt text"><br>发现他的数据通信是http协议的，可是发送数据和返回数据都是加密过的（逆向表哥可以试试跟踪处理过程，web渣表示无能为力）</p><p>除了wireshark，还尝试过进xp系统用fiddler抓包，这里其实抓到的数据更多，但是。。。。。我忘记截图了，就很尴尬😳。后面也试过用神器burpsuite，但可能代理这边一直无法设置，也没有做进一步的改包实验。结合之前看到的一篇论文，这边稍微对抓包后的结果总结一下：<br>1、微信通过内置浏览器和服务器交互数据。 <br>微信在应用层使用HTTP协议传输数据。微信点击网址链接，会跳转到浏览器模式，打开该消息对应的网页。而且用wireshark抓包发现微信的通信都是用HTTP协议收发数据的，内嵌浏览器为网络通信接口。（之前课上和老师争论过关于http和https协议的应用问题，现在想想有点傻，哈哈哈）<br>2、微信的数据用SSL加密传输。</p><p>接下来从其他方面做一个分析（为了凑出老师说好的十个要点我也是很拼了！！！求表扬求发糖&#x3D;-&#x3D;）<br>1、C&#x2F;S通信模式<br><img src="/assets/blog/8.png" alt="Alt text"><br>（图来自书《网络是怎样连接的》，强烈安利）<br>2、p2p对等模式<br>整个网络结构中不存在中心节点（或中心服务器）。在P2P结构中，每一个节点（peer）大都同时具有信息消费者、信息提供者和信息通讯等三方面的功能。<br>3、微信技术是基于即时通信技术原理的一种<br>当前使用的IM系统大都组合使用了C&#x2F;S和P2P模式。在登录IM进行身份认证阶段是工作在C&#x2F;S方式,随后如果客户端之间可以直接通信则使用P2P方式工作，否则以C&#x2F;S方式通过IM服务器通信。<br>4、手机分为电源部分，逻辑部分，射频部分，输入输出部分<br>    首先输入输出部分指的是触摸屏，麦克风，听筒等（手机触摸屏分为两种：电阻屏和电容屏。电阻触屏：需用压力使屏幕各层发生接触。电容触屏：来自带电的手指表层最细微的接触也能激活屏幕下方的电容感应系统。）<br>    逻辑部分是指CPU，字库，暂存等，作用就是控制手机的各项操作。<br>    射频部分就是信号部分，有功放，滤波，中频IC等，管接收和发射，<br>    电源是各元器件的供电。<br>发信息时，按字后根据触摸点在屏幕的坐标位置进行识别，再将字在此时作为输出设备的屏幕上显示。</p><p>计算机组成原理学得比较浅，很多东西的理解都还浮在表面，还是希望自己能再多花时间去学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。&lt;/p&gt;
&lt;p&gt;从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="course" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>记第一次线下赛</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/</id>
    <published>2017-12-11T06:25:08.000Z</published>
    <updated>2022-09-01T06:11:38.802Z</updated>
    
    <content type="html"><![CDATA[<p>今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。</p><h2 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h2><p>attack with defence赛制，也就是ctf线下赛。<br>比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。</p><span id="more"></span><h2 id="比赛环境-网络拓扑图"><a href="#比赛环境-网络拓扑图" class="headerlink" title="比赛环境 网络拓扑图"></a>比赛环境 网络拓扑图</h2><p>计网没学好的后遗症，哇，刚开始一直分不清网段，不知道对手在哪，一脸懵逼简直生无可恋。所以，要分清区段和端口！！！<br>    <img src="/assets/blog/3.png" alt="Alt text"></p><blockquote><p>维护的时候需要连接到本队 GameBox 所在网段上，根据主办方提供的 CTF 账号与密码登录。而与其他队伍的 GameBox 交互时则需要连接到对应的网段里与漏洞程序进行交互。提交 flag 则需要到指定的答题平台上提交。</p></blockquote><h2 id="答案提交形式"><a href="#答案提交形式" class="headerlink" title="答案提交形式"></a>答案提交形式</h2><ol><li>攻破其他选手的GameBox,并在GameBox上寻找flag文件；</li><li>在答题页面上登陆后提交flag；</li><li>比赛提供自动提交flag的接口，接口地址需要使用post方式提交，并需要两个参数：answer和token<br><em>这次比赛就是靠大佬写的脚本批量提交flag，排名蹭蹭往上涨～</em></li><li>flag每轮次刷新。</li></ol><h2 id="“涨姿势”"><a href="#“涨姿势”" class="headerlink" title="“涨姿势”"></a>“涨姿势”</h2><p>来来来，敲黑板，划重点！</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><blockquote><p>比赛开始后第一时间备份服务器中web目录下的文件(&#x2F;var&#x2F;www&#x2F;html)，这是自我审计的基础，也是防止服务器在比赛中出现异常的情况下可以立即恢复到初始状态的先决条件。有的比赛可以提供3次左右的恢复初始设置的机会，有的比赛不提供，所以备份十分重要。<br>    可以用ssh user@hostname命令，也可以用图形化工具xshell等。</p></blockquote><h3 id="找主机"><a href="#找主机" class="headerlink" title="找主机"></a>找主机</h3><pre><code> ‘’nmap –sn 192.168.71.0/24‘’</code></pre><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门。<br>发现后门后，第一时间删除或者注释掉，同时利用这个漏洞发起第一波攻击。</p><h3 id="挂waf"><a href="#挂waf" class="headerlink" title="挂waf"></a>挂waf</h3><p>没看清大佬操作，以后再补0.0</p><h3 id="口令问题"><a href="#口令问题" class="headerlink" title="口令问题"></a>口令问题</h3><blockquote><p>弱口令的问题几乎是必考，比赛开始后，如果发现每个队伍的SSH账号密码都是一样的（某次比赛中都是phpcms、wordpress），需要立即修改口令，如果被其他队伍改了那就gg了。Web后台很有可能存在弱口令，一般都是admin&#x2F;admin,admin&#x2F;123456,test&#x2F;test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p></blockquote><h3 id="文件监控-日志分析"><a href="#文件监控-日志分析" class="headerlink" title="文件监控 日志分析"></a>文件监控 日志分析</h3><p> 除了感知攻击，嘿嘿嘿，最重要的是“抄作业”。<br> 然后一定注意权限！</p><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>常见的cms漏洞要熟悉，然后一般漏洞包括SQL注入、文件包含、文件上传等等。</p><h3 id="关注-Gamebox-状态"><a href="#关注-Gamebox-状态" class="headerlink" title="关注 Gamebox 状态"></a>关注 Gamebox 状态</h3><p>一定要注意关注本队Gamebox状态，后面因为服务器down掉了超级多分，就很蓝瘦。。。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html">https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html</a><br><a href="http://bobao.360.cn/ctf/detail/169.html">http://bobao.360.cn/ctf/detail/169.html</a><br><a href="https://www.t00ls.net/articles-40843.html">https://www.t00ls.net/articles-40843.html</a><br><a href="http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg">http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg</a></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>挺开心的一天下来，虽然刚开始因为没带mac的网线转换头沮丧了很久，但是江sir人真的超好啊（没错，就是我队大佬！），不嫌弃拖后腿的我这个小辣鸡，还陪着我到处跑去买转换头。全程看大佬操作，还超nice的讲解，这波很值啊！明天把环境本地复现再玩玩，具体的比赛“姿势”回头补篇笔记，嘿嘿嘿。然后代码审计、脚本编写很很很重要，一些常见的题目漏洞类型要好好掌握（sql、文件包含、各种rce、文件上传），就酱紫～还是希望能趁着大三上学期再多玩玩多学点，怀挺！</p><p>2017-12-08</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。&lt;/p&gt;
&lt;h2 id=&quot;AWD&quot;&gt;&lt;a href=&quot;#AWD&quot; class=&quot;headerlink&quot; title=&quot;AWD&quot;&gt;&lt;/a&gt;AWD&lt;/h2&gt;&lt;p&gt;attack with defence赛制，也就是ctf线下赛。&lt;br&gt;比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/life/"/>
    
    
    <category term="feeling" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/feeling/"/>
    
  </entry>
  
</feed>
