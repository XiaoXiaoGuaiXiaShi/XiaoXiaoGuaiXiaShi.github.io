<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DQQ&#39;s blog</title>
  
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://xiaoxiaoguaixiashi.github.io.git/"/>
  <updated>2022-08-31T07:03:45.824Z</updated>
  <id>https://xiaoxiaoguaixiashi.github.io.git/</id>
  
  <author>
    <name>DQQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>eBPF初步学习</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2022/08/28/eBPF/</id>
    <published>2022-08-28T12:37:31.000Z</published>
    <updated>2022-08-31T07:03:45.824Z</updated>
    
    <content type="html"><![CDATA[<p>2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让<strong>操作系统内核可编程化</strong>，成为云原生时代软件系统的一把利刃。</p><span id="more"></span><h2 id="一、eBPF概念"><a href="#一、eBPF概念" class="headerlink" title="一、eBPF概念"></a>一、eBPF概念</h2><ul><li>BPF：Berkeley Packet Filter，伯克利包过滤器。<br></li><li>发明之初被称为cBPF（classic BPF），是一款网络过滤神器，衍生工具有tcpdump等。<br></li><li>发展演进成一套通用执行引擎eBPF（extended Berkeley Packet Filter），不再仅仅是网络分析，还可以基于eBPF开发性能分析、系统追踪、网络优化等多种类型的工具和平台。<br></li></ul><h3 id="1-1-为什么需要BPF"><a href="#1-1-为什么需要BPF" class="headerlink" title="1.1 为什么需要BPF"></a>1.1 为什么需要BPF</h3><p>过去的程序为了分析只在内核空间运行的数据，必须将数据从内核空间复制到用户空间的内存中去，并进行上下文切换。而这与直接在内核空间分析数据相比，产生了巨大的性能开销。随着近年来网络速度和流量的快速增长（音频、视频流媒体数据），在用户空间监控分析那么多的流量数据已经不可行了，一种在内核空间执行高效安全的程序的机制BPF就应运而生了。<br><br>1992年，《The BSD Packet Filter: A New Architecture for User-level Packet Capture》论文中第一次提出BPF技术，文中描述了如何在Unix内核实现网络数据包过滤，比当时的数据包过滤技术快20倍。<br></p><h3 id="1-2-BPF内核编程的好处"><a href="#1-2-BPF内核编程的好处" class="headerlink" title="1.2 BPF内核编程的好处"></a>1.2 BPF内核编程的好处</h3><p>传统的Linux内核开发需要实现强安全、高性能和持续交付。<br><br>现有的方案存在以下问题：</p><ul><li>1）直接修改内核代码——&gt;内核版本更新满，每次功能更新都需要重新编译打包内核代码；<br></li><li>2）开发新的可即时加载的内核模块，用户可以在运行时加载到Linux内核中进而扩展内核功能——&gt;内核模块需要跟着内核版本的更新进行调整，此外还存在让内核crash的风险。<br></li></ul><p>BPF通过BPF验证器、JIT编译器和用户空间可编程三个特性实现了内核开发的需求：</p><ul><li>1）强安全：BPF验证器（verifier）会检查将要运行到内核空间的程序的每一行是否安全可靠，如果检查不通过，它将拒绝这个程序被加载到内核中去，从而保证内核本身不会崩溃<em>（这是不同于开发内核模块的）</em>。<br></li><li>2）高性能：Just-In-Time（指令即时翻译）编译器保证了程序本地运行的高性能。<br></li><li>3）持续交付：可以在不影响系统运行的情况下，实时在线地替换这些运行在Linux内核中的eBPF程序。<br></li></ul><h3 id="1-3-eBPF架构"><a href="#1-3-eBPF架构" class="headerlink" title="1.3 eBPF架构"></a>1.3 eBPF架构</h3><p>介绍：用户把eBPF程序编译为eBPF指令，然后通过bpf()系统调用将eBPF指令加载到内核的特定挂载点，由特定的事件来触发eBPF指令的执行。在挂载eBPF指令时内核会进行充分验证，避免eBPF代码影响内核的安全和稳定性。另外内核也会进行JIT编译，把eBPF指令翻译为本地指令，减少性能开销。<br></p><p><img src="/assets/blog/eBPF-1.jpg" alt="Alt text"><br></p><center>图来自https://www.ebpf.top/post/ebpf_intro/</center><p>eBPF用户空间程序和内核中的BPF字节码交互流程如下：</p><ul><li>1）用户自定义程序，使用LLVM或GCC工具将编写的BPF代码程序编译成BPF字节码。<br></li><li>2）字节码被装载到内核VM中，基于类RISC指令的VM运行在内核空间。<br></li><li>3）其中，字节码通过BPF Verifier确保内核安全。<br></li><li>4）验证后的字节码通过BPF JIT机制转成内核可执行的本地指令运行。<br></li></ul><p>上述流程中涉及到的程序的装载过程具体是：通过<strong>bpf()系统调用</strong>将eBPF程序装载到内核中，其中包含多种bpf命令，用于用户空间与内核VM交互。<br><br>注意：BPF程序不是以机器指令加载到内核的，而是以字节码形式加载到内核中的。<br><img src="/assets/blog/eBPF-2.jpg" alt="Alt text"><br></p><p>上述流程中涉及到的程序验证具体是：保证程序的安全执行，不破坏内核。主要验证程序的权限、程序不能对内核有损害、程序能够结束（循坏有限）等。<br><br>eBPF是事件驱动的，当内核或应用程序通过某个挂钩点时运行。预定义的钩子包括系统调用、函数入口&#x2F;出口、内核跟踪点、网络事件和其他钩子。<br></p><p><img src="/assets/blog/eBPF-3.jpg" alt="Alt text"><br></p><center>图来自(eBPF概念及在可观测性、网络、安全和优化领域的应用)</center><p>内核中运行的BPF字节码程序可以使用两种方式将测量数据回传至用户空间：<br></p><ul><li>1）eBPF maps，被设计成 key&#x2F;value 的形式，能够在用户态程序与内核态eBPF程序之间进行双向通信。<br></li><li>2）perf-event 用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析。<br></li></ul><h2 id="二、eBPF编程"><a href="#二、eBPF编程" class="headerlink" title="二、eBPF编程"></a>二、eBPF编程</h2><p>BPF开发工具总结如下图，这里笔者主要使用bpftrace和libbpf-bootstrap进行内核跟踪的开发实践。<br><br><img src="/assets/blog/eBPF-4.jpg" alt="Alt text"><br></p><h3 id="2-1-bpftrace实践"><a href="#2-1-bpftrace实践" class="headerlink" title="2.1 bpftrace实践"></a>2.1 bpftrace实践</h3><p>bpftrace在eBPF和BCC之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的跟踪功能。</p><blockquote><p>安装bpftrace参考：<a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md%EF%BC%8C%E8%8B%A5%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E2%80%9Clockdown">https://github.com/iovisor/bpftrace/blob/master/INSTALL.md，若未正确安装可能会出现“lockdown</a> is enabled and set to ‘confidentiality’”报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l &#x27;*execve*&#x27;</span><br><span class="line">sudo bpftrace -l ｜grep execve</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这些函数可以分为 tracepoint（内核静态探针），kprobe（内核态动态函数探针）和 kfunc （基于BPF的内核态动态函数探针）三类。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kfunc，kprobe属于不稳定接口，而tracepoint则是稳定接口。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因而，优先选择更稳定的跟踪点，以保证 eBPF 程序的可移植性（即在不同版本的内核中都可以正常执行）。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-5.jpg" alt="Alt text"><br></p><h4 id="2-1-1-tracepoint跟踪"><a href="#2-1-1-tracepoint跟踪" class="headerlink" title="2.1.1 tracepoint跟踪"></a>2.1.1 tracepoint跟踪</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪系统调用execve查看入口参数</span></span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_exit_execve &#123; printf(&quot;%-6d %-8s ret=%d \n&quot;,pid,comm,args-&gt;ret); &#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;join(args-&gt;argv);&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;tracepoint:syscalls:sys_enter_execve &#123; printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bpftrace -e ：表示直接从后面的字符串参数中读入bpftrace程序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tracepoint:syscalls:sys_enter_execve表示跟踪的函数，如果多个函数可以用逗号分隔，后面&#123;&#125;中表示跟踪点的处理函数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理函数如：<span class="built_in">printf</span>()表示向终端中打印字符串，其用法就是C语言中的<span class="built_in">printf</span>()函数。其中pid和<span class="built_in">comm</span>是bpftrace内置的变量，分别表示进程PID和进程名称。</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-6.jpg" alt="Alt text"><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还可以写成脚本的形式：vim jiaoben.bt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bpftrace</span></span><br><span class="line">tracepoint:syscalls:sys_enter_execve </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%-6d %s called %s\n&quot;,pid,comm,str(args-&gt;filename)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 sudo ./jiaoben.bt 即可达到上述命令行效果</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-kprobe监控"><a href="#2-1-2-kprobe监控" class="headerlink" title="2.1.2 kprobe监控"></a>2.1.2 kprobe监控</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核动态探针kprobe监控内核函数vfs_open的跟踪点和入口参数</span></span><br><span class="line">sudo bpftrace -lv kfunc:vfs_open</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内核函数的调用栈</span></span><br><span class="line">sudo bpftrace -e &#x27;kprobe:vfs_open &#123; @[kstack(perf)] = count(); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-7.jpg" alt="Alt text"><br></p><h4 id="2-1-3-用户态函数探针检测"><a href="#2-1-3-用户态函数探针检测" class="headerlink" title="2.1.3 用户态函数探针检测"></a>2.1.3 用户态函数探针检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用用户态函数探针 uprobe和uprobe检测用户态的程序test</span></span><br><span class="line"><span class="comment">// 编写test.c文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成test应用程序：gcc -g test.c -o test</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用bpftrace跟踪<span class="built_in">test</span>程序的main函数，输出参数个数、第1个参数和返回值：</span></span><br><span class="line">sudo bpftrace -e &#x27;uprobe:/home/jian/Desktop/bpf/third/test:main &#123;printf(&quot;count:%d  &quot;,arg0);join(arg1)&#125;&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/home/jian/Desktop/bpf/third/test:main &#123; printf(&quot;test main return %d\n&quot;, retval); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用用户态函数探针 uretprobe检测开源应用程序bash</span></span><br><span class="line">sudo bpftrace -e &#x27;uretprobe:/usr/bin/bash:readline &#123; printf(&quot;User %d executed \&quot;%s\&quot; command\n&quot;, uid, str(retval)); &#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/assets/blog/eBPF-8.jpg" alt="Alt text"><br></p><h4 id="2-1-4-事件检测"><a href="#2-1-4-事件检测" class="headerlink" title="2.1.4 事件检测"></a>2.1.4 事件检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针Software检测软件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;s:*&#x27;</span><br><span class="line">sudo bpftrace -e &#x27;software:page-faults:100 &#123; @[comm] = count(); &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用探针hardware检测硬件事件</span></span><br><span class="line">sudo bpftrace  -l &#x27;h:*&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟机环境不支持</span></span><br></pre></td></tr></table></figure><h3 id="2-2-libbpf实践"><a href="#2-2-libbpf实践" class="headerlink" title="2.2 libbpf实践"></a>2.2 libbpf实践</h3><p>BCC依赖于LLVM和内核头文件才可以动态编译和加载eBPF程序，然而，很多环境中通常没有甚至不允许安装这些开发工具。其中一种解决方案就是使用libbpf来开发一个eBPF程序。<br></p><blockquote><p>首先需要知道，一个以开发BPF程序为目的的工程通常由两类源文件组成：</p><ul><li>一类是运行于内核态的BPF程序的源代码文件.</li><li>另外一类是用于向内核加载BPF程序、从内核卸载BPF程序、与内核态进行数据交互、展现用户态程序逻辑的用户态程序的源代码文件。</li></ul></blockquote><h4 id="2-2-1-基于libbpf-bootstrap项目的实现"><a href="#2-2-1-基于libbpf-bootstrap项目的实现" class="headerlink" title="2.2.1 基于libbpf-bootstrap项目的实现"></a>2.2.1 基于libbpf-bootstrap项目的实现</h4><p>内核BPF开发者Andrii Nakryiko在github上开源了一个直接基于libbpf开发BPF程序与加载器的引导项目libbpf-bootstrap，这个项目中包含使用c和rust开发BPF程序和用户态程序的例子。下图是基于libbpf-bootstrap实现的hello world程序实例的示意图。</p><p><img src="/assets/blog/eBPF-9.jpg" alt="Alt text"><br></p><center>图来自参考链接“使用C语言...eBPF程序”</center><ul><li>图中的libbpf其实是指linux内核代码库中的tools&#x2F;lib&#x2F;bpf，是内核提供给外部开发者的C库，用于创建BPF用户态的程序。<br></li><li>图中的bpftool对应的是linux内核代码库中的tools&#x2F;bpf&#x2F;bpftool，是一个bpf辅助工具，在libbpf-bootstrap中用于生成xx.skel.h。（在eBPF程序中，由于内核已经支持了BTF，因此不再需要引入众多的内核头文件来获取内核数据结构的定义。取而代之的是一个通过bpftool生成的vmlinux.h头文件——也就是xx.skel.h，其中包含了内核数据结构的定义。<br></li><li>helloworld.bpf.c是bpf程序对应的源码，通过clang -target&#x3D;bpf编译成BPF字节码ELF文件helloworld.bpf.o。<br></li><li>libbpf-bootstrap并没有使用用户态加载程序直接去加载helloworld.bpf.o，而是通过bpftool gen命令基于helloworld.bpf.o生成helloworld.skel.h文件，在生成的helloworld.skel.h文件中包含了BPF程序的字节码以及加载、卸载对应BPF程序的函数，我们在用户态程序直接调用即可。<br></li><li>helloworld.c是BPF用户态程序，它只需要include helloworld.skel.h并按套路加载、挂接BPF程序到内核层对应的埋点即可。由于BPF程序内嵌到用户态程序中，我们在分发BPF程序时只需分发用户态程序即可！<br></li></ul><p>结合上述流程分析，基于libbpf-bootstrap的eBPF程序的开发流程如下：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.下载libbpf-bootstrap</span></span><br><span class="line">git clone https://github.com/libbpf/libbpf-bootstrap.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.初始化和更新libbpf-bootstrap的依赖</span></span><br><span class="line">cat .gitmodules</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.基于libbpf-bootstrap框架的BPF程序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入libbpf-bootstrap/examples/c目录下，在该目录下创建两个C源文件helloworld.bpf.c和helloworld.c(参考了minimal.bpf.c和minimal.c)，显然前者是运行在内核态的BPF程序的源码，而后者则是用于加载BPF到内核的用户态程序。</span></span><br><span class="line">cd libbpf-bootstrap/examples/c</span><br></pre></td></tr></table></figure><h4 id="2-2-2-基于libbpf的独立实现"><a href="#2-2-2-基于libbpf的独立实现" class="headerlink" title="2.2.2 基于libbpf的独立实现"></a>2.2.2 基于libbpf的独立实现</h4><p>使用libbpf开发eBPF程序也是需要内核态的eBPF程序和用户态的加载、挂载、映射读取以及输出程序的，步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装libbpf库和bpftool工具。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.在任意路径下建立一个helloworld目录，将前面的helloworld.bpf.c和helloworld.c拷贝到该helloworld目录下。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.编写Makefile。整个Makefile的构建过程与libbpf-bootstrap中的Makefile异曲同工，同样是先编译bpf字节码，然后生成内核头文件helloworld.skel.h。最后编译依赖helloworld.skel.h的helloworld程序。</span></span><br></pre></td></tr></table></figure><h2 id="三、推荐学习路径"><a href="#三、推荐学习路径" class="headerlink" title="三、推荐学习路径"></a>三、推荐学习路径</h2><p>参考狄卫华老师推荐的<a href="">eBPF学习路径</a>，结合自身的学习情况，整理了一些对个人帮助较大的博客和资料，按照不同阶段的学习需求总结如下：</p><h3 id="3-1-了解eBPF发展背景和相关概念"><a href="#3-1-了解eBPF发展背景和相关概念" class="headerlink" title="3.1 了解eBPF发展背景和相关概念"></a>3.1 了解eBPF发展背景和相关概念</h3><ul><li><a href="https://www.ebpf.top/post/ebpf_intro/">博客文章——eBPF技术简介</a></li><li><a href="https://www.bilibili.com/video/BV1PF411V7Lj?share_source=copy_web&vd_source=28532461e369234a7808585e999e9e49">B站视频——陈鹏飞：eBPF概念及在可观测性、网络、安全和优化领域的应用</a></li><li><a href="https://www.youtube.com/watch?v=uBqRv8bDroc&t=2s">Youtube视频——Liz Rice：A Beginner’s Guide to eBPF</a></li></ul><h3 id="3-2-初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解"><a href="#3-2-初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解" class="headerlink" title="3.2 初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解"></a>3.2 初步探索eBPF编程并结合实践进一步深化对eBPF相关功能的理解</h3><ul><li><a href="https://www.cnblogs.com/lfri/p/15402973.html">博客文章——BPF C编程入门</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123005213">博客文章——使用bpfttrace开发eBEP程序</a></li><li><a href="https://blog.csdn.net/sinat_22338935/article/details/123318084">博客文章——使用libbpf开发eBPF程序</a></li><li><a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch/">博客文章——使用C语言从头开发一个Hello World级别的eBPF程序</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210627/">博客文章——使用libbpf-bootstrap构建BPF程序</a></li></ul><h3 id="3-3-穿插书籍阅读，分模块深入"><a href="#3-3-穿插书籍阅读，分模块深入" class="headerlink" title="3.3 穿插书籍阅读，分模块深入"></a>3.3 穿插书籍阅读，分模块深入</h3><ul><li>《Linux内核观测技术BPF》</li></ul><h2 id="四、国内eBPF实践团队"><a href="#四、国内eBPF实践团队" class="headerlink" title="四、国内eBPF实践团队"></a>四、国内eBPF实践团队</h2><ul><li>字节跳动STE团队</li><li>阿里云荣旸</li><li>腾讯云TKE团队</li><li>eBay IE Cloud团队</li><li>网易杭研轻舟云原生</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2014年，eBPF扩展到用户空间，吸引了越来越多的关注。当前，eBPF相关的知名的开源项目包括Facebook的高性能4层负载均衡器Katran，具备API感知和安全高效的容器网络方案Cilium等。eBPF让&lt;strong&gt;操作系统内核可编程化&lt;/strong&gt;，成为云原生时代软件系统的一把利刃。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="eBPF" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 本地提权漏洞（CVE-2017-16995）</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2018/03/22/cve-2017-16995/</id>
    <published>2018-03-22T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Ubuntu 16.04.1~16.04.4<br>Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）</p><span id="more"></span><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>该漏洞存在于调用eBPF bpf(2)的Linux内核系统中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题， 低权限用户可使用此漏洞获得管理权限。</p><blockquote><p>eBPF - extended Berkeley Packet Filter<br>  简单理解就是用于过滤网络数据包。</p></blockquote><p>EXP下载链接：<a href="https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip">https://www.hackersb.cn/usr/uploads/2018/03/1930063493.zip</a></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本来刚开始打算虚拟机复现的，结果安装完发现下的是内核版本为GNU&#x2F;Linux 4.13.0-37-generic x86_64的Ubuntu 16.04，就很难受😣。<br>于是利用i春秋的实验平台复现了一下，结果如下：<br><img src="/assets/blog/1.png" alt="Alt text"></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>Ubuntu 官网暂时没有提供修复方案，可以在评估风险后通过修改内核参数限制普通用户使用 bpf(2) 系统调用来临时修复此漏洞。<br><img src="/assets/blog/2.png" alt="Alt text"></p><blockquote><p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;unprivileged_bpf_disabled</p></blockquote><p>彻底根治方案：更新内核。</p><p>参考链接：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html">eBPF 简史</a><br><a href="https://mp.weixin.qq.com/s/51txDsanj-uSqXdm5GZuEA">i春秋实验</a><br><a href="http://www.yunweipai.com/archives/25298.html">http://www.yunweipai.com/archives/25298.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h4&gt;&lt;p&gt;Ubuntu 16.04.1~16.04.4&lt;br&gt;Linux Kernel Version 4.14-4.4 （主要影响 Debian 和 Ubuntu 发行版，Redhat 和 CentOS 不受影响。）&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="CVE" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>微信是怎样发送消息的</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/28/weixin/</id>
    <published>2017-12-28T12:37:31.000Z</published>
    <updated>2018-09-22T05:11:08.009Z</updated>
    
    <content type="html"><![CDATA[<p>从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。</p><p>从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。</p><span id="more"></span><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="/assets/blog/4.png" alt="Alt text">  （图来自课上赵老师）</p><p> 这边首先对数据流量和wifi二者的区别做一个简单介绍：<br>    1、数据流量是通过基站，如果基站覆盖范围大的话，信号接收当然会比wifi好。<br>    2、而wifi是通过wifi接入点（或者简单点理解就是无线路由器），再通过学校交换机，再通过中继器，再通过运营商的路由器。</p><p>手机将文字、图片、语音等数据通过电磁波为载体，在空气中经过上图传播流程后，通过运营商给你接通的讯道传输到对方手机。当手机接收到信号之后再把信号转换，从而实现双方的消息传递。</p><p><em>并没有学过通信原理，这边很多概念也都一知半解，只能浅显地给出自己的一些理解，大佬们轻喷@_@</em></p><h2 id="数据链路层、网络层"><a href="#数据链路层、网络层" class="headerlink" title="数据链路层、网络层"></a>数据链路层、网络层</h2><p>其实在上一段的图中已经提及了，这边也不进一步分析了。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><img src="/assets/blog/5.png" alt="Alt text">    （图来自网络）<br>这边即时通讯关于UDP和TCP的使用区别还是很重要的一个点，也许很多人一听到这个就会下意识地背出“tcp是面向连接的可靠交付，而udp是无连接的不可靠交付”，深入下去其实并不简单。<br>微信既有UDP也有TCP！</p><blockquote><p>UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。微信采用的通信协议以UDP为主，辅以TCP协议。由于微信的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。<br>微信客户端之间的消息传送也采用了UDP模式，因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此微信选择了UDP作为客户之间的主要通信协议。</p></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层这边还是直接看操作吧～</p><p>尝试用wireshark抓包（由于mac微信无法设置代理，也有可能是我还不太熟悉…..这边是对网页版微信的一个抓包）：<br><img src="/assets/blog/6.png" alt="Alt text"><br>先是建立TCP连接：如图前面是TCP的三次握手：<br>    首先客户端向服务器发送标志为SYN的连接请求，数据包标号Seq&#x3D;0；  <br>    收到请求后，服务器向客户端发送了带有SYN和ACK的确认应答，发送序号Seq&#x3D;0，确认序号ACK&#x3D;1；接下来，客户端向服务器发送确认应答，Seq&#x3D;1，ACK&#x3D;1. 连接建立完成。 <br>后面紧跟着的是HTTP数据包，数据最后一行为空行，表明数据已经传送完毕，如下图所示：<br><img src="/assets/blog/7.png" alt="Alt text"><br>发现他的数据通信是http协议的，可是发送数据和返回数据都是加密过的（逆向表哥可以试试跟踪处理过程，web渣表示无能为力）</p><p>除了wireshark，还尝试过进xp系统用fiddler抓包，这里其实抓到的数据更多，但是。。。。。我忘记截图了，就很尴尬😳。后面也试过用神器burpsuite，但可能代理这边一直无法设置，也没有做进一步的改包实验。结合之前看到的一篇论文，这边稍微对抓包后的结果总结一下：<br>1、微信通过内置浏览器和服务器交互数据。 <br>微信在应用层使用HTTP协议传输数据。微信点击网址链接，会跳转到浏览器模式，打开该消息对应的网页。而且用wireshark抓包发现微信的通信都是用HTTP协议收发数据的，内嵌浏览器为网络通信接口。（之前课上和老师争论过关于http和https协议的应用问题，现在想想有点傻，哈哈哈）<br>2、微信的数据用SSL加密传输。</p><p>接下来从其他方面做一个分析（为了凑出老师说好的十个要点我也是很拼了！！！求表扬求发糖&#x3D;-&#x3D;）<br>1、C&#x2F;S通信模式<br><img src="/assets/blog/8.png" alt="Alt text"><br>（图来自书《网络是怎样连接的》，强烈安利）<br>2、p2p对等模式<br>整个网络结构中不存在中心节点（或中心服务器）。在P2P结构中，每一个节点（peer）大都同时具有信息消费者、信息提供者和信息通讯等三方面的功能。<br>3、微信技术是基于即时通信技术原理的一种<br>当前使用的IM系统大都组合使用了C&#x2F;S和P2P模式。在登录IM进行身份认证阶段是工作在C&#x2F;S方式,随后如果客户端之间可以直接通信则使用P2P方式工作，否则以C&#x2F;S方式通过IM服务器通信。<br>4、手机分为电源部分，逻辑部分，射频部分，输入输出部分<br>    首先输入输出部分指的是触摸屏，麦克风，听筒等（手机触摸屏分为两种：电阻屏和电容屏。电阻触屏：需用压力使屏幕各层发生接触。电容触屏：来自带电的手指表层最细微的接触也能激活屏幕下方的电容感应系统。）<br>    逻辑部分是指CPU，字库，暂存等，作用就是控制手机的各项操作。<br>    射频部分就是信号部分，有功放，滤波，中频IC等，管接收和发射，<br>    电源是各元器件的供电。<br>发信息时，按字后根据触摸点在屏幕的坐标位置进行识别，再将字在此时作为输出设备的屏幕上显示。</p><p>计算机组成原理学得比较浅，很多东西的理解都还浮在表面，还是希望自己能再多花时间去学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从课上提出这个问题开始，就一直想着找个时间总结一下，顺便梳理一下思路。0.0奈何拖延症晚期，直到考试前一天的今晚，在大家相互询问的害怕和后一天考试的焦虑种种消极因素的影响下，终于开始整理了。废话不多说，进入正题。&lt;/p&gt;
&lt;p&gt;从自己手机微信对话框中输入消息，到对方手机接收并显示出消息内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自岗位上相互配合完成了一系列的工作。接下来从计算机网络的五层体系结构分别做一个简单的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/study/"/>
    
    
    <category term="course" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>记第一次线下赛</title>
    <link href="https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/"/>
    <id>https://xiaoxiaoguaixiashi.github.io.git/2017/12/11/AWD-1/</id>
    <published>2017-12-11T06:25:08.000Z</published>
    <updated>2018-09-22T05:11:08.010Z</updated>
    
    <content type="html"><![CDATA[<p>今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。</p><h2 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h2><p>attack with defence赛制，也就是ctf线下赛。<br>比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。</p><span id="more"></span><h2 id="比赛环境-网络拓扑图"><a href="#比赛环境-网络拓扑图" class="headerlink" title="比赛环境 网络拓扑图"></a>比赛环境 网络拓扑图</h2><p>计网没学好的后遗症，哇，刚开始一直分不清网段，不知道对手在哪，一脸懵逼简直生无可恋。所以，要分清区段和端口！！！<br>    <img src="/assets/blog/3.png" alt="Alt text"></p><blockquote><p>维护的时候需要连接到本队 GameBox 所在网段上，根据主办方提供的 CTF 账号与密码登录。而与其他队伍的 GameBox 交互时则需要连接到对应的网段里与漏洞程序进行交互。提交 flag 则需要到指定的答题平台上提交。</p></blockquote><h2 id="答案提交形式"><a href="#答案提交形式" class="headerlink" title="答案提交形式"></a>答案提交形式</h2><ol><li>攻破其他选手的GameBox,并在GameBox上寻找flag文件；</li><li>在答题页面上登陆后提交flag；</li><li>比赛提供自动提交flag的接口，接口地址需要使用post方式提交，并需要两个参数：answer和token<br><em>这次比赛就是靠大佬写的脚本批量提交flag，排名蹭蹭往上涨～</em></li><li>flag每轮次刷新。</li></ol><h2 id="“涨姿势”"><a href="#“涨姿势”" class="headerlink" title="“涨姿势”"></a>“涨姿势”</h2><p>来来来，敲黑板，划重点！</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><blockquote><p>比赛开始后第一时间备份服务器中web目录下的文件(&#x2F;var&#x2F;www&#x2F;html)，这是自我审计的基础，也是防止服务器在比赛中出现异常的情况下可以立即恢复到初始状态的先决条件。有的比赛可以提供3次左右的恢复初始设置的机会，有的比赛不提供，所以备份十分重要。<br>    可以用ssh user@hostname命令，也可以用图形化工具xshell等。</p></blockquote><h3 id="找主机"><a href="#找主机" class="headerlink" title="找主机"></a>找主机</h3><pre><code> ‘’nmap –sn 192.168.71.0/24‘’</code></pre><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门。<br>发现后门后，第一时间删除或者注释掉，同时利用这个漏洞发起第一波攻击。</p><h3 id="挂waf"><a href="#挂waf" class="headerlink" title="挂waf"></a>挂waf</h3><p>没看清大佬操作，以后再补0.0</p><h3 id="口令问题"><a href="#口令问题" class="headerlink" title="口令问题"></a>口令问题</h3><blockquote><p>弱口令的问题几乎是必考，比赛开始后，如果发现每个队伍的SSH账号密码都是一样的（某次比赛中都是phpcms、wordpress），需要立即修改口令，如果被其他队伍改了那就gg了。Web后台很有可能存在弱口令，一般都是admin&#x2F;admin,admin&#x2F;123456,test&#x2F;test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p></blockquote><h3 id="文件监控-日志分析"><a href="#文件监控-日志分析" class="headerlink" title="文件监控 日志分析"></a>文件监控 日志分析</h3><p> 除了感知攻击，嘿嘿嘿，最重要的是“抄作业”。<br> 然后一定注意权限！</p><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>常见的cms漏洞要熟悉，然后一般漏洞包括SQL注入、文件包含、文件上传等等。</p><h3 id="关注-Gamebox-状态"><a href="#关注-Gamebox-状态" class="headerlink" title="关注 Gamebox 状态"></a>关注 Gamebox 状态</h3><p>一定要注意关注本队Gamebox状态，后面因为服务器down掉了超级多分，就很蓝瘦。。。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html">https://ctf-wiki.github.io/ctf-wiki/introduction/experience.html</a><br><a href="http://bobao.360.cn/ctf/detail/169.html">http://bobao.360.cn/ctf/detail/169.html</a><br><a href="https://www.t00ls.net/articles-40843.html">https://www.t00ls.net/articles-40843.html</a><br><a href="http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg">http://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg</a></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>挺开心的一天下来，虽然刚开始因为没带mac的网线转换头沮丧了很久，但是江sir人真的超好啊（没错，就是我队大佬！），不嫌弃拖后腿的我这个小辣鸡，还陪着我到处跑去买转换头。全程看大佬操作，还超nice的讲解，这波很值啊！明天把环境本地复现再玩玩，具体的比赛“姿势”回头补篇笔记，嘿嘿嘿。然后代码审计、脚本编写很很很重要，一些常见的题目漏洞类型要好好掌握（sql、文件包含、各种rce、文件上传），就酱紫～还是希望能趁着大三上学期再多玩玩多学点，怀挺！</p><p>2017-12-08</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天第一次打AWD比赛，全靠大佬carry，学到很多姿势（没错，包括腰酸脖子疼！），挺有意思的，稍微记录总结一下。&lt;/p&gt;
&lt;h2 id=&quot;AWD&quot;&gt;&lt;a href=&quot;#AWD&quot; class=&quot;headerlink&quot; title=&quot;AWD&quot;&gt;&lt;/a&gt;AWD&lt;/h2&gt;&lt;p&gt;attack with defence赛制，也就是ctf线下赛。&lt;br&gt;比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://xiaoxiaoguaixiashi.github.io.git/categories/life/"/>
    
    
    <category term="config" scheme="https://xiaoxiaoguaixiashi.github.io.git/tags/config/"/>
    
  </entry>
  
</feed>
